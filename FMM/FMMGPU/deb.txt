#include <fstream>
#include "basis_quadratures.hpp"
#include "exeptions.hpp"

using namespace std;

BasisQuadratures::BasisQuadratures()
{
   _order = 0;
}

void BasisQuadratures::initFromTXT(string coordsFileName, string weightsFileName)
{
   initCoordinatesFromTXT(coordsFileName);
   initWeightsFromTXT(weightsFileName);
}

int BasisQuadratures::order() const
{
   return _order;
}

const Vector3& BasisQuadratures::values(size_t i) const
{
   return _values[i];
}

real BasisQuadratures::w(size_t i) const
{
   return _w[i];
}

void BasisQuadratures::initCoordinatesFromTXT(std::string coordsFileName)
{
   ifstream fin(coordsFileName, ios_base::in);

   if(fin.fail())
      throw Exeption();

   fin.exceptions(ifstream::badbit | ifstream::failbit);

   try
   {
      real x_coord, y_coord, z_coord;

      while(fin >> x_coord && fin >> y_coord && fin >> z_coord)
      {
         _values.push_back(Vector3(x_coord, y_coord, z_coord));
      }

   }
   catch(ifstream::failure e)
   {
      if(!fin.eof())
      {
         fin.close();
         throw ParsingExeption();
      }
      else
      {
         _order = _values.size();
         fin.close();
      }
   }
}

void BasisQuadratures::initWeightsFromTXT(std::string weightsFileName)
{
   ifstream fin(weightsFileName, ios_base::in);

   if(fin.fail())
      throw Exeption("No such file!");

   fin.exceptions(ifstream::badbit | ifstream::failbit);

   try
   {
      real w_value;

      while(fin >> w_value)
      {
         _w.push_back(w_value);
      }

   }
   catch(ifstream::failure e)
   {
      if(!fin.eof())
      {
         fin.close();
         throw ParsingExeption();
      }
      else
      {
         if(_w.size() != _order)
            throw Exeption("Bad data!");

         fin.close();
      }
   }
}

#pragma once
#include "real.hpp"
#include "vector3.cuh"
#include <vector>
#include <string>

class BasisQuadratures
{
private:
   int _order;
   std::vector<Vector3> _values;
   std::vector<real> _w;

public:

   BasisQuadratures();
   void initFromTXT(std::string coordsFileName, std::string weightsFileName);

   int order() const;
   const Vector3& values(size_t i) const;
   real w(size_t i) const;

private:
   void initCoordinatesFromTXT(std::string coordsFileName);
   void initWeightsFromTXT( std::string weightsFileName);
};#include "bem_quadrature.hpp"

BEMQuadrature::BEMQuadrature(
   const Vector3& coordinates,
   real area,
   real weight,
   const Vector3& B,
   const Vector3& normal):
   Quadrature(coordinates, area, weight), B(B), normal(normal)
{

}
#pragma once
#include "quadrature.hpp"

struct BEMQuadrature : public Quadrature
{
   Vector3 B;
   Vector3 normal;

   BEMQuadrature() = default;
   BEMQuadrature(
      const Vector3& coordinates,
      real area,
      real weight,
      const Vector3& B,
      const Vector3& normal);
};﻿#include "blass_callers.hpp"

void blas::multMatrices(
   const CBLAS_ORDER order,
   const CBLAS_TRANSPOSE transA, const CBLAS_TRANSPOSE transB,
   const blasint m, const blasint n, const blasint k,
   const real alpha,
   const real* a, const blasint lda,
   const real* b, const blasint ldb,
   const real beta,
   real* c, const blasint ldc)
{
#ifdef REAL_IS_FLOAT

   cblas_sgemm(
      order, transA, transB, m, n, k, alpha, 
      a, lda, b, ldb, beta, c, ldc);

#endif

#ifdef REAL_IS_DOUBLE
   
   cblas_dgemm(
      order, transA, transB, m, n, k, alpha,
      a, lda, b, ldb, beta, c, ldc);

#endif
}

void blas::multComplexMatrices(
   CBLAS_ORDER order,
   CBLAS_TRANSPOSE transA,
   CBLAS_TRANSPOSE transB,
   blasint m, blasint n, blasint k,
   real* alpha,
   real* a, blasint lda,
   real* b, blasint ldb,
   real* beta,
   real* c, blasint ldc)
{
#ifdef REAL_IS_FLOAT

   cblas_cgemm(
      order, transA, transB, m, n, k, alpha,
      a, lda, b, ldb, beta, c, ldc);

#endif

#ifdef REAL_IS_DOUBLE

   cblas_zgemm(
      order, transA, transB, m, n, k, alpha,
      a, lda, b, ldb, beta, c, ldc);

#endif
}

void blas::multMatricesCUBLAS(
   cublasHandle_t handle,
   cublasOperation_t transa,
   cublasOperation_t transb,
   int m, int n, int k,
   const real* alpha,
   const real* a, int lda,
   const real* b, int ldb,
   const real* beta,
   real* c, int ldc)
{
#ifdef REAL_IS_FLOAT

   cublasSgemm_v2(
      handle, transa, transb, m, n, k, alpha,
      a, lda, b, ldb, beta, c, ldc);

#endif

#ifdef REAL_IS_DOUBLE

   cublasDgemm_v2(
      handle, transa, transb, m, n, k, alpha,
      a, lda, b, ldb, beta, c, ldc);

#endif
}

void blas::multMatricesStridedBatchedCUBLAS(
   cublasHandle_t handle,
   cublasOperation_t transa,
   cublasOperation_t transb,
   int m, int n, int k,
   const real* alpha,
   const real* A,int lda, long long strideA,
   const real* B, int ldb, long long strideB,
   const real* beta,
   real* C, int ldc, long long strideC,
   int batchCount)
{
#ifdef REAL_IS_FLOAT

   cublasSgemmStridedBatched(
      handle, transa, transb, m, n, k, alpha,
      A, lda, strideA, B, ldb, strideB, beta,
      C, ldc, strideC, batchCount);

#endif

#ifdef REAL_IS_DOUBLE

   cublasDgemmStridedBatched(
      handle, transa, transb, m, n, k, alpha,
      A, lda, strideA, B, ldb, strideB, beta,
      C, ldc, strideC, batchCount);

#endif
}

void blas::copyVector(
   blasint n,
   const real* x,
   blasint incx,
   real* y,
   blasint incy)
{
#ifdef REAL_IS_FLOAT

   cblas_scopy(n, x, incx, y, incy);

#endif

#ifdef REAL_IS_DOUBLE

   cblas_dcopy(n, x, incx, y, incy);

#endif
}

void blas::addVectorToVector(
   blasint n,
   real alpha,
   const real* x,
   blasint incx,
   real* y,
   blasint incy)
{
#ifdef REAL_IS_FLOAT

   cblas_saxpy(n, alpha, x, incx, y, incy);

#endif

#ifdef REAL_IS_DOUBLE

   cblas_daxpy(n, alpha, x, incx, y, incy);

#endif
}
﻿#pragma once
#include <cblas.h>
#include "real.hpp"
#include "cublasLt.h"

namespace blas
{
   void multMatrices(
      CBLAS_ORDER order,
      CBLAS_TRANSPOSE transA,
      CBLAS_TRANSPOSE transB,
      blasint m, blasint n, blasint k,
      real alpha,
      const real* a, blasint lda,
      const real* b, blasint ldb,
      real beta,
      real* c, blasint ldc);

   void multComplexMatrices(
      CBLAS_ORDER order, 
      CBLAS_TRANSPOSE transA,
      CBLAS_TRANSPOSE transB,
      blasint m, blasint n, blasint k,
      real* alpha,
      real* a, blasint lda,
      real* b, blasint ldb,
      real* beta,
      real* c, blasint ldc);


   void multMatricesCUBLAS(
      cublasHandle_t handle,
      cublasOperation_t transa,
      cublasOperation_t transb,
      int m, int n, int k,
      const real* alpha,
      const real* a, int lda,
      const real* b, int ldb,
      const real* beta,
      real* c, int ldc);

   void multMatricesStridedBatchedCUBLAS(
      cublasHandle_t handle,
      cublasOperation_t transa,
      cublasOperation_t transb,
      int m, int n, int k,
      const real* alpha,
      const real* A, int lda, long long int strideA,
      const real* B, int ldb, long long int strideB,
      const real* beta, real* C, int ldc, long long int strideC,
      int batchCount);

   void copyVector(
      blasint n,
      const real* x,
      blasint incx,
      real* y,
      blasint incy);

   void addVectorToVector(
      blasint n,
      real alpha,
      const real* x,
      blasint incx, real* y,
      blasint incy);
}
#include <math.h>
#include "box.hpp"

Box::Box()
{
}

Box::Box(const Vector3& center, const Vector3& halfDimensions):
   _center(center), _halfDimensions(halfDimensions)
{
}

bool isInRange(real value, real rangeCenter, real rangeHalfWidth)
{
   return (rangeCenter - rangeHalfWidth <= value &&
           value < rangeCenter + rangeHalfWidth);
}

bool Box::contains(const Vector3& point) const
{
   return (isInRange(point.x, _center.x, _halfDimensions.x) &&
           isInRange(point.y, _center.y, _halfDimensions.y) &&
           isInRange(point.z, _center.z, _halfDimensions.z));
}

bool Box::contains(const Box& box) const
{
   return isInRange(box.center().x - box.halfDimensions().x, _center.x, _halfDimensions.x) &&
          isInRange(box.center().x + box.halfDimensions().x, _center.x, _halfDimensions.x) &&
          isInRange(box.center().y - box.halfDimensions().y, _center.y, _halfDimensions.y) &&
          isInRange(box.center().y + box.halfDimensions().y, _center.y, _halfDimensions.y) &&
          isInRange(box.center().z - box.halfDimensions().z, _center.z, _halfDimensions.z) &&
          isInRange(box.center().z + box.halfDimensions().z, _center.z, _halfDimensions.z);
}

bool Box::intersects(const Box& _box) const
{
   return Box(_box.center(), _halfDimensions + _box.halfDimensions()).contains(center());
}

real Box::radius() const
{
    return sqrt(_halfDimensions.x * _halfDimensions.x + 
                _halfDimensions.y * _halfDimensions.y + 
                _halfDimensions.z * _halfDimensions.z);
}

const Vector3& Box::center() const
{
   return _center;
}

const Vector3& Box::halfDimensions() const
{
   return _halfDimensions;
}

//
//real Box::left() const
//{
//   return center.x - halfDimensions.x;
//}
//
//real Box::right() const
//{
//   return center.x + halfDimensions.x;
//}
//
//real Box::top() const
//{
//   return center.y - halfDimensions.y;
//}
//
//real Box::bot() const
//{
//   return center.y + halfDimensions.y;
//}
//
//real Box::near() const
//{
//   return center.z - halfDimensions.z;
//}
//
//real Box::far() const
//{
//   return center.z + halfDimensions.z;
//}
#pragma once
#include "vector3.cuh"

class Box
{
private:
   Vector3 _center;
   Vector3 _halfDimensions;

public:
   Box();
   Box(const Vector3& center, const Vector3& halfDimensions);
   bool contains(const Vector3& point) const;
   bool contains(const Box& box) const;
   bool intersects(const Box& _box) const;
   real radius() const;

   const Vector3& center() const;
   const Vector3& halfDimensions() const;
};#include "calculation_point_octree.hpp"
#include "quadrature_octree.hpp"

#include <iostream>

#include "integration.hpp"
#include "harmonics.hpp"
#include "multipole_translator.hpp"

#include <thrust/complex.h>

CalculationPointOctreeNode::CalculationPointOctreeNode() : 
   _parent(nullptr)
{
}

CalculationPointOctreeNode::CalculationPointOctreeNode(
   const Box& box,
   const size_t capacity,
   CalculationPointOctreeNode* parent) :
   _parent(parent), _box(box), _capacity(capacity)
{

}

void CalculationPointOctreeNode::insert(std::vector<Vector3>& points)
{
   for(auto& point : points)
   {
      insert(point);
   }
}

void CalculationPointOctreeNode::insert(Vector3& point)
{
   if(!_box.contains(point))
   {
      return;
   }

   if(_points.size() < _capacity)
   {
      if(!isSubdivided())
      {
         _points.push_back(&point);
      }
      else
      {
         for(auto& child : _children)
         {
            child->insert(point);
         }
      }
   }
   else
   {
      subdivide();

      _points.push_back(&point);

      for(auto p : _points)
      {
         for(auto& child : _children)
         {
            child->insert(*p);
         }
      }

      _points.clear();
      _points.shrink_to_fit();
   }
}

void CalculationPointOctreeNode::subdivide()
{
   float x = _box.center().x;
   float y = _box.center().y;
   float z = _box.center().z;

   float w = _box.halfDimensions().x;
   float h = _box.halfDimensions().y;
   float d = _box.halfDimensions().z;

   Vector3 childrenHalfDimensions = { w / 2, h / 2, d / 2 };

   _children.reserve(8);

   _children.emplace_back(new CalculationPointOctreeNode(Box({ x - w / 2, y - h / 2, z - d / 2 }, childrenHalfDimensions), _capacity, this));
   _children.emplace_back(new CalculationPointOctreeNode(Box({ x + w / 2, y - h / 2, z - d / 2 }, childrenHalfDimensions), _capacity, this));
   _children.emplace_back(new CalculationPointOctreeNode(Box({ x + w / 2, y + h / 2, z - d / 2 }, childrenHalfDimensions), _capacity, this));
   _children.emplace_back(new CalculationPointOctreeNode(Box({ x - w / 2, y + h / 2, z - d / 2 }, childrenHalfDimensions), _capacity, this));

   _children.emplace_back(new CalculationPointOctreeNode(Box({ x - w / 2, y - h / 2, z + d / 2 }, childrenHalfDimensions), _capacity, this));
   _children.emplace_back(new CalculationPointOctreeNode(Box({ x + w / 2, y - h / 2, z + d / 2 }, childrenHalfDimensions), _capacity, this));
   _children.emplace_back(new CalculationPointOctreeNode(Box({ x + w / 2, y + h / 2, z + d / 2 }, childrenHalfDimensions), _capacity, this));
   _children.emplace_back(new CalculationPointOctreeNode(Box({ x - w / 2, y + h / 2, z + d / 2 }, childrenHalfDimensions), _capacity, this));
}

std::vector<CalculationPointOctreeNode*> CalculationPointOctreeNode::getAllNodes()
{
   std::vector<CalculationPointOctreeNode*> result;
   result.push_back(this);

   for(auto child : _children)
   {
      auto childChildren = child->getAllNodes();
      result.insert(result.end(), childChildren.begin(), childChildren.end());
   }

   return result;
}

std::set<CalculationPointOctreeNode*> CalculationPointOctreeNode::getAllNodesAsSet()
{
   std::set<CalculationPointOctreeNode*> result;
   result.insert(this);

   for(auto child : _children)
   {
      if(child->isSubdivided() || !child->points().empty())
      {
         auto childChildren = child->getAllNodesAsSet();
         result.insert(childChildren.begin(), childChildren.end());
      }
   }

   return result;
}

std::vector<Vector3*> CalculationPointOctreeNode::getAllPoints() const
{
   std::vector<Vector3*> result;
   result.insert(result.end(), _points.begin(), _points.end());

   for(auto child : _children)
   {
      auto childPoints = child->getAllPoints();
      result.insert(result.end(), childPoints.begin(), childPoints.end());
   }

   return result;
}

size_t CalculationPointOctreeNode::getAllNodeCount() const
{
   size_t count = 1;

   if(isSubdivided())
   {
      count += 8;

      for(auto child : _children)
      {
         count += child->getAllNodeCount();
      }
   }
   
   return count;
}

std::vector<FMMResult> CalculationPointOctreeNode::calcA(size_t pointCount)
{
   std::vector<FMMResult> res;
   res.reserve(pointCount);
   calcA(res);

   return res;
}

std::vector<FMMResult> CalculationPointOctreeNode::calcRot(size_t pointCount)
{
   std::vector<FMMResult> res;
   res.reserve(pointCount);
   calcRot(res);

   return res;
}

void CalculationPointOctreeNode::initAllLocalExpansions(size_t order)
{
   if(isSubdivided() || !_points.empty())
   {
      _localExpansion = HarmonicSeries<Vector3>(order);

      for(auto child : _children)
      {
         child->initAllLocalExpansions(order);
      }
   }
}

void CalculationPointOctreeNode::calcA(std::vector<FMMResult>& result)
{
   if(!_points.empty())
   {
      for(auto point : _points)
      {
         auto translation = *point - _box.center();
         auto regularHarmonic = Harmonics::calcRegularSolidHarmonics(
            _localExpansion.order(), translation);
         Vector3 aInPoint = mult(_localExpansion, regularHarmonic);
         result.emplace_back(*point, aInPoint , this);
      }
   }
   else
   {
      for (auto child : _children)
      {
         child->calcA(result);
      }
   }
}

void CalculationPointOctreeNode::calcRot(std::vector<FMMResult>& result)
{
   size_t order = _localExpansion.order();
   real eps = 1e-3;

   if(isUsefullLeaf())
   {
      for(auto point : _points)
      {
         Vector3 res;
         
         auto hx1 = Harmonics::calcRegularSolidHarmonics(
            order, *point - _box.center() + Vector3::xAxis() * eps);
         auto hx2 = Harmonics::calcRegularSolidHarmonics(
            order, *point - _box.center() - Vector3::xAxis() * eps);

         auto hy1 = Harmonics::calcRegularSolidHarmonics(
            order, *point - _box.center() + Vector3::yAxis() * eps);
         auto hy2 = Harmonics::calcRegularSolidHarmonics(
            order, *point - _box.center() - Vector3::yAxis() * eps);

         auto hz1 = Harmonics::calcRegularSolidHarmonics(
            order, *point - _box.center() + Vector3::zAxis() * eps);
         auto hz2 = Harmonics::calcRegularSolidHarmonics(
            order, *point - _box.center() - Vector3::zAxis() * eps);

         hx1.subtract(hx2);
         hy1.subtract(hy2);
         hz1.subtract(hz2);

         Vector3 tempRes;

         for(int l = 0; l <= order; l++)
         {
            for(int m = -l; m <= l; m++)
            {
               tempRes.x += 
                  _localExpansion.getHarmonic(l, m).z * hy1.getHarmonic(l, m) -
                  _localExpansion.getHarmonic(l, m).y * hz1.getHarmonic(l, m);

               tempRes.y += 
                  _localExpansion.getHarmonic(l, m).x * hz1.getHarmonic(l, m) -
                  _localExpansion.getHarmonic(l, m).z * hx1.getHarmonic(l, m);

               tempRes.z += 
                  _localExpansion.getHarmonic(l, m).y * hx1.getHarmonic(l, m) -
                  _localExpansion.getHarmonic(l, m).x * hy1.getHarmonic(l, m);
            }
         }

         res += tempRes / (2 * eps);
         result.emplace_back(*point, res, this);
      }
   }
   else
   {
      for(auto child : _children)
      {
         child->calcRot(result);
      }
   }
}

void CalculationPointOctreeNode::propagateLocalExpansions() const
{
   if(_localExpansion.order() != 0)
   {
      for(auto child : _children)
      {
         if(child->localExpansion().order() !=0 &&
            (child->isSubdivided() || !child->points().empty()))
         {
            auto translation = _box.center() - child->box().center();
            child->_localExpansion.add(
               MultipoleTranslator::translateLocalWithComplex(
                  _localExpansion,
                  translation));
         }
      }
   }

   for(auto child : _children)
   {
      child->propagateLocalExpansions();
   }
}

const Box& CalculationPointOctreeNode::box() const
{
   return this->_box;
}

bool CalculationPointOctreeNode::isSubdivided() const
{
   return !_children.empty();
}

bool CalculationPointOctreeNode::isUsefullLeaf() const
{
   return !_points.empty();
}

CalculationPointOctreeNode* CalculationPointOctreeNode::parent()
{
   return _parent;
}

CalculationPointOctreeNode* CalculationPointOctreeNode::parent() const
{
   return _parent;
}

std::vector<CalculationPointOctreeNode*>& CalculationPointOctreeNode::children()
{
   return _children;
}

const std::vector<CalculationPointOctreeNode*>& CalculationPointOctreeNode::children() const
{
   return _children;
}

const std::vector<Vector3*>& CalculationPointOctreeNode::points() const
{
   return _points;
}

HarmonicSeries<Vector3>& CalculationPointOctreeNode::localExpansion()
{
   return _localExpansion;
}

const HarmonicSeries<Vector3>& CalculationPointOctreeNode::localExpansion() const
{
   return _localExpansion;
}

CalculationPointOctreeNode::~CalculationPointOctreeNode()
{
   for(auto child : _children)
   {
      delete child;
   }
}#pragma once
#include <vector>
#include <set>

#include "vector3.cuh"
#include "box.hpp"
#include "harmonic_series.hpp"

class QuadratureOctreeNode;
class CalculationPointOctreeNode;

struct FMMResult
{
   Vector3 point;
   Vector3 answer;
   CalculationPointOctreeNode* node;
};

class CalculationPointOctreeNode
{
private:
   size_t _capacity = 0;
   Box _box;
   std::vector<Vector3*> _points;
   std::vector<CalculationPointOctreeNode*> _children;
   HarmonicSeries<Vector3> _localExpansion;
   CalculationPointOctreeNode* _parent;
 
public:
   //std::set<QuadratureOctreeNode*> leftToInteractWith;

   CalculationPointOctreeNode();
   CalculationPointOctreeNode(
      const Box& box,
      const size_t capacity,
      CalculationPointOctreeNode* parent = nullptr);

   void insert(Vector3& point);
   void insert(std::vector<Vector3>& points);
   void subdivide();

   const Box& box() const;
   bool isSubdivided() const;
   bool isUsefullLeaf() const;
   CalculationPointOctreeNode* parent();
   CalculationPointOctreeNode* parent() const;
   std::vector<CalculationPointOctreeNode*>& children();
   const std::vector<CalculationPointOctreeNode*>& children() const;
   const std::vector<Vector3*>& points() const;
   HarmonicSeries<Vector3>& localExpansion();
   const HarmonicSeries<Vector3>& localExpansion() const;

   std::vector<CalculationPointOctreeNode*> getAllNodes();
   std::set<CalculationPointOctreeNode*> getAllNodesAsSet();
   std::vector<Vector3*> getAllPoints() const;
   size_t getAllNodeCount() const;
   std::vector<FMMResult> calcA(size_t pointCount);
   std::vector<FMMResult> calcRot(size_t pointCount);

   void initAllLocalExpansions(size_t order);
   void propagateLocalExpansions() const;

   ~CalculationPointOctreeNode();
private:
   void calcA(std::vector<FMMResult>& result);
   void calcRot(std::vector<FMMResult>& result);

};#include <stdio.h>
#include <cstdlib>
#include <chrono>

#include "cuda_helper.hpp"

namespace cuda
{
   void tryKernelLaunch()
   {
      cudaError_t cudaStatus = cudaGetLastError();

      if(cudaStatus != cudaError::cudaSuccess)
      {
         printf("Kernel launch failed!\n");

         std::exit(0);
      }
   }

   void tryKernelSynchronize()
   {
      cudaError_t cudaStatus = cudaDeviceSynchronize();

      if(cudaStatus != cudaError::cudaSuccess)
      {
         printf("Kernel synchrinisation failed!\n");

         std::exit(0);
      }
   }
}#pragma once
#include "cuda_runtime.h"

namespace cuda
{
   void tryKernelLaunch();
   void tryKernelSynchronize();

   // Gets next closest integer to number that is devisible on devider
   size_t nextDevisible(const size_t number, const size_t devidor);
}#include "cylinder.hpp"

#include "math.hpp"

Cylinder::Cylinder(
   real bottom,
   real top,
   real radius,
   size_t widthSegmentCount,
   size_t heightSegmentCount,
   size_t depthSegmentCount)
{
   _sideTriangles.reserve(widthSegmentCount * heightSegmentCount * 2);

   real width = 2 * math::PI;
   real segmentWidth = width / widthSegmentCount;
   real segmentHeight = (top - bottom) / heightSegmentCount;

   Vector3 widthSegmentStep(segmentWidth, 0, 0);
   Vector3 heightSegmentStep(0, 0, segmentHeight);

   for(size_t h = 0; h < heightSegmentCount; h++)
   {
      Vector3 currentHeight(0, 0, segmentHeight * h + bottom);

      for(size_t w = 0; w < widthSegmentCount; w++)
      {
         Vector3 currentWidth(segmentWidth * w, 0, 0);
         Vector3 triangleBase = currentWidth + currentHeight + Vector3(0, radius, 0);

         _sideTriangles.emplace_back(
            triangleBase,
            triangleBase + widthSegmentStep,
            triangleBase + heightSegmentStep);

         _sideTriangles.emplace_back(
            triangleBase + widthSegmentStep + heightSegmentStep,
            triangleBase + widthSegmentStep,
            triangleBase + heightSegmentStep);
      }
   }

   real segmentDepth = radius / depthSegmentCount;
   Vector3 depthSegmentStep(0, segmentDepth, 0);

   _topTriangles.reserve(depthSegmentCount * widthSegmentCount * 2);

   for(size_t d = 0; d < depthSegmentCount; d++)
   {
      Vector3 currentDepth(0, segmentDepth * d, 0);

      for(size_t w = 0; w < widthSegmentCount; w++)
      {
         Vector3 currentWidth(segmentWidth * w, 0, 0);
         Vector3 triangleBase = currentWidth + currentDepth + Vector3(0, 0, top);

         _topTriangles.emplace_back(
            triangleBase,
            triangleBase + widthSegmentStep,
            triangleBase + depthSegmentStep);

         _topTriangles.emplace_back(
            triangleBase + widthSegmentStep + depthSegmentStep,
            triangleBase + widthSegmentStep,
            triangleBase + depthSegmentStep);
      }
   }

   _bottomTriangles = _topTriangles;

   for (auto &bottomTriangle : _bottomTriangles)
   {
      bottomTriangle.a().z = bottom;
      bottomTriangle.b().z = bottom;
      bottomTriangle.c().z = bottom;
   }
}

std::vector<Triangle>& Cylinder::sideTriangles()
{
   return _sideTriangles;
}

const std::vector<Triangle>& Cylinder::sideTriangles() const
{
   return _sideTriangles;
}

std::vector<Triangle>& Cylinder::topTriangles()
{
   return _topTriangles;
}

const std::vector<Triangle>& Cylinder::topTriangles() const
{
   return _topTriangles;
}

std::vector<Triangle>& Cylinder::bottomTriangles()
{
   return _bottomTriangles;
}

const std::vector<Triangle>& Cylinder::bottomTriangles() const
{
   return _bottomTriangles;
}
#pragma once
#include "real.hpp"
#include "triangle.hpp"

class Cylinder
{
private:
   std::vector<Triangle> _sideTriangles;
   std::vector<Triangle> _topTriangles;
   std::vector<Triangle> _bottomTriangles;

public:
   Cylinder(
      real bottom,
      real top,
      real radius,
      size_t widthSegmentCount,
      size_t heightSegmentCount,
      size_t depthSegmentCount);

   std::vector<Triangle>& sideTriangles();
   const std::vector<Triangle>& sideTriangles() const;

   std::vector<Triangle>& topTriangles();
   const std::vector<Triangle>& topTriangles() const;

   std::vector<Triangle>& bottomTriangles();
   const std::vector<Triangle>& bottomTriangles() const;

private:
};
#pragma once
#include "cuda_runtime.h"
#include "cuda_helper.hpp"
#include "math.hpp"

namespace cuda
{
   template <class T> class DevPtr
   {
   private:
      T* _data = nullptr;
      size_t _size = 0;
      size_t _sizePadded = 0;
      DevPtr(const DevPtr&) = delete;

   public:
      DevPtr();
      ~DevPtr<T>();
      DevPtr<T>(size_t size, size_t padding = 0);
      DevPtr<T>(const T* data, size_t size, size_t padding = 0);

      T* data() const;

      void copyToHost(T* result);
      void copyToDevice(const T* source);
      void allocateSpaceForData(size_t size, size_t padding);

      size_t size() const;
      size_t sizePadded() const;

      DevPtr& operator=(DevPtr& devPtr);
      DevPtr& operator=(DevPtr&& devPtr);
   };

   template<class T>
   DevPtr<T>::DevPtr()
   {

   }

   template<class T>
   DevPtr<T>::~DevPtr<T>()
   {
      cudaFree(_data);
   }

   template<class T>
   DevPtr<T>::DevPtr<T>(size_t size, size_t padding)
   {
      try
      {
         allocateSpaceForData(size, padding);
      }
      catch(std::exception e)
      {
         throw e;
      }
   }

   template<class T>
   DevPtr<T>::DevPtr<T>(const T* data, size_t size, size_t padding)
   {
      try
      {
         allocateSpaceForData(size, padding);
         copyToDevice(data);
      }
      catch(std::exception e)
      {
         throw e;
      }
   }

   template<class T>
   void DevPtr<T>::allocateSpaceForData(size_t size, size_t padding)
   {
      cudaFree(_data);

      _sizePadded = math::nextDevisible(size, padding);
      _size = size;

      cudaError_t result = cudaMalloc((void**)&_data,
                                      _sizePadded * sizeof(T));

      if(result != cudaError_t::cudaSuccess)
         throw std::exception("deb");
   }

   template<class T>
   T* DevPtr<T>::data() const
   {
      return _data;
   }

   template<class T>
   void DevPtr<T>::copyToHost(T* result)
   {
      cudaError_t resultMessage = 
         cudaMemcpy(result, _data, _size * sizeof(T),
                    cudaMemcpyKind::cudaMemcpyDeviceToHost);

      if(resultMessage != cudaError_t::cudaSuccess)
         throw std::exception();
   }

   template<class T>
   void DevPtr<T>::copyToDevice(const T* source)
   {
      cudaError_t results = cudaMemcpy(_data,
                                      source,
                                      _size * sizeof(T),
                                      cudaMemcpyKind::cudaMemcpyHostToDevice);

      if(results != cudaError_t::cudaSuccess)
         throw std::exception();
   }

   template<class T>
   size_t DevPtr<T>::size() const
   {
      return _size;
   }

   template<class T>
   inline size_t DevPtr<T>::sizePadded() const
   {
      return _sizePadded;
   }

   template<class T>
   DevPtr<T>& DevPtr<T>::operator=(DevPtr& devPtr)
   {
      allocateSpaceForData(devPtr._size);

      cudaMemcpy(_data,
                 devPtr._data,
                 devPtr._sizePadded * sizeof(T),
                 cudaMemcpyKind::cudaMemcpyDeviceToDevice);

      _size = devPtr._size;
      _sizePadded = devPtr._sizePadded;

      return *this;
   }

   template<class T>
   DevPtr<T>& DevPtr<T>::operator=(DevPtr&& devPtr)
   {
      _data = devPtr._data;
      _size = devPtr._size;
      _sizePadded = devPtr._sizePadded;

      devPtr._data = nullptr;
      devPtr._size = 0;
      devPtr._sizePadded = 0;

      return *this;
   }
}#include "exeptions.hpp"

std::ostream& operator<<(std::ostream& out, const Exeption& exeption)
{
   out << exeption.message;
   return out;
}

Exeption::Exeption() : message("Error!") {}
Exeption::Exeption(std::string message) : message(message) {}

ParsingExeption::ParsingExeption() : Exeption("Parsing exeption!") {}

MallocExeption::MallocExeption() : Exeption("Malloc exeption!") {}

CopyExeption::CopyExeption() : Exeption("Copy exeption!") {}
#pragma once
#include <string>
#include <ostream>

class NotImplementedExeption{};
class RangeExeption{};

class Exeption
{
public:
   std::string message;
   Exeption();
   Exeption(std::string message);
};

class ParsingExeption : public Exeption
{
public:
   ParsingExeption();
};

class MallocExeption : public Exeption
{
public:
   MallocExeption();
};

class CopyExeption : public Exeption
{
public:
   CopyExeption();
};

std::ostream& operator <<(std::ostream& out, const Exeption& exeption);
#include "factorials.hpp"

Factorials::Factorials()
{
   _factorials.resize(maxFactorialNum);
   _factorials[0] = 1;

   for(size_t i = 1; i < maxFactorialNum; i++)
   {
      _factorials[i] = _factorials[i - 1] * i;
   }
}

size_t Factorials::operator[](size_t i) const
{
   return _factorials[i];
}
#pragma once
#include <vector>
#include "real.hpp"

class Factorials
{
private:
   std::vector<real> _factorials;
public:
   const size_t maxFactorialNum = 100;
   Factorials();
   size_t operator[](size_t i) const;
};

﻿#include <iomanip>
#include <iostream>
#include <chrono>
#include <cblas.h>

#include "fast_multipole_solver.hpp"
#include "multipole_translator.hpp"
#include "testing_helpers.hpp"
#include "translation_algorithms.hpp"
#include "blass_callers.hpp"

FastMultipoleSolver::FastMultipoleSolver(
   std::vector<Quadrature>& quadratures,
   std::vector<Vector3>& points,
   Problem problem,
   size_t quadratureOctreeLeafCapacity,
   size_t calculationPointOctreeLeafCapacity) :
   MultipoleSolver(quadratures, problem, quadratureOctreeLeafCapacity),
   _points(points),
   calculationPointOctreeLeafCapacity(calculationPointOctreeLeafCapacity)
{
   initTrees();
}

FastMultipoleSolver::FastMultipoleSolver(
   std::vector<BEMQuadrature>& quadratures,
   std::vector<Vector3>& points,
   Problem problem,
   size_t quadratureOctreeLeafCapacity,
   size_t calculationPointOctreeLeafCapacity) :
   MultipoleSolver(quadratures, problem, quadratureOctreeLeafCapacity),
   _points(points),
   calculationPointOctreeLeafCapacity(calculationPointOctreeLeafCapacity)
{
   initTrees();
}

FastMultipoleSolver::~FastMultipoleSolver()
{
   delete _calculationPointOctreeRoot;
}

void FastMultipoleSolver::initTrees()
{
   auto start = std::chrono::steady_clock::now();
   MultipoleSolver::initTrees();
   auto stop = std::chrono::steady_clock::now();
   auto time = test::getTime(start, stop);

   //std::cout << time << " ";

   start = std::chrono::steady_clock::now();
   _calculationPointOctreeRoot = new CalculationPointOctreeNode(
      math::getBoundingBox(_points), calculationPointOctreeLeafCapacity);
   _calculationPointOctreeRoot->insert(_points);
   stop = std::chrono::steady_clock::now();
   time = test::getTime(start, stop);

   //std::cout << time << " ";
}

void FastMultipoleSolver::calcLocalMultipoleExpansions(
   M2LAlg algorithm,
   Device device)
{
   if(_multipolesAreReady)
   {
      if(!_localMultipolesAreInitialized)
      {
         _calculationPointOctreeRoot->initAllLocalExpansions(harmonicOrder);
         _localMultipolesAreInitialized = true;
      }

      formInteractionMaps(
         _quadratureOctreeRoot,
         _calculationPointOctreeRoot);

      accountFarInteractions();

      switch(algorithm)
      {
         case M2LAlg::ComplexTranslation:
         {
            propagateLocalExpansionsWithComplexTranslation();
            break;
         }
         case M2LAlg::Matrices:
         {
            propagateLocalExpansionsWithMatrices(device);
            break;
         }
         default:
         {
            throw std::exception("Not implemented!");
         }
      }
   }
   else
   {
      throw std::exception("Multipoles are not ready!");
   }
}


void FastMultipoleSolver::formInteractionMaps(
   QuadratureOctreeNode* quadratureTreeNode,
   CalculationPointOctreeNode* calcPointTreeNode)
{
   if(!((quadratureTreeNode->isSubdivided() || quadratureTreeNode->isUsefullLeaf()) &&
        (calcPointTreeNode->isSubdivided() || calcPointTreeNode->isUsefullLeaf())))
   {
      return;
   }

   if(checkIfFarEnough(quadratureTreeNode, calcPointTreeNode))
   {
      _farInteractionMap[calcPointTreeNode].insert(quadratureTreeNode);
   }
   else
   {
      if(calcPointTreeNode->isUsefullLeaf())
      {
         bool сhildrenAreCloseEnough = true;

         for(auto child : quadratureTreeNode->children())
         {
            if(checkIfFarEnough(child, calcPointTreeNode))
            {
               сhildrenAreCloseEnough = false;
               break;
            }
         }

         if(сhildrenAreCloseEnough)
         {
            _closeInteractionMap[calcPointTreeNode].insert(quadratureTreeNode);
         }
         else
         {
            for(auto child : quadratureTreeNode->children())
            {
               formInteractionMaps(child, calcPointTreeNode);
            }
         }
      }
      else
      {
         if((calcPointTreeNode->box().radius() < quadratureTreeNode->box().radius() ||
             calcPointTreeNode->isUsefullLeaf()) && !quadratureTreeNode->isUsefullLeaf())
         {
            for(auto child : quadratureTreeNode->children())
            {
               formInteractionMaps(child, calcPointTreeNode);
            }
         }
         else
         {
            for(auto child : calcPointTreeNode->children())
            {
               formInteractionMaps(quadratureTreeNode, child);
            }
         }
      }
   }
}

bool FastMultipoleSolver::checkIfFarEnough(
   const QuadratureOctreeNode* quadratureTreeNode,
   const CalculationPointOctreeNode* calcPointTreeNode) const
{
   real radius1 = quadratureTreeNode->box().radius();
   real radius2 = calcPointTreeNode->box().radius();

   real minRadius = std::min(radius1, radius2);
   real maxRadius = std::max(radius1, radius2);

   real minimalDistance = 2 * maxRadius + minRadius;

   real distanceSquared = (
      quadratureTreeNode->box().center() -
      calcPointTreeNode->box().center()).lengthSquared();

   return minimalDistance * minimalDistance < distanceSquared;
}

Vector3 FastMultipoleSolver::calcA(real current, const Vector3& point)
{
   return MultipoleSolver::calcA(current, point);
}
Vector3 FastMultipoleSolver::calcB(real current, const Vector3& point)
{
   return MultipoleSolver::calcB(current, point);
}

std::vector<std::pair<Vector3, Vector3>> FastMultipoleSolver::calcA(real current)
{
   auto ffmResults = _calculationPointOctreeRoot->calcA(_points.size());
   std::vector<std::pair<Vector3, Vector3>> result;
   result.reserve(ffmResults.size());

   for(auto& [point, answer, node] : ffmResults)
   {
      for(auto interactionNode : _closeInteractionMap[node])
      {
         answer += interactionNode->calcA(point);
      }

      result.emplace_back(point, answer / (4.0 * math::PI) * current);
   }

   return result;
}

std::vector<std::pair<Vector3, Vector3>> FastMultipoleSolver::calcB(real current)
{
   auto ffmResults = _calculationPointOctreeRoot->calcRot(_points.size());
   std::vector<std::pair<Vector3, Vector3>> result;
   result.reserve(ffmResults.size());

   for(auto& [point, answer, node] : ffmResults)
   {
      for(auto interactionNode : _closeInteractionMap[node])
      {
         answer += interactionNode->calcRot(point);
      }

      result.emplace_back(point, answer / (4.0 * math::PI) * current * math::MU0);
   }

   return result;
}

std::vector<std::pair<Vector3, Vector3>> FastMultipoleSolver::calcBEM(real current)
{
   auto ffmResults = _calculationPointOctreeRoot->calcA(_points.size());
   std::vector<std::pair<Vector3, Vector3>> result;
   result.reserve(ffmResults.size());

   for(auto& [point, answer, node] : ffmResults)
   {
      for(auto interactionNode : _closeInteractionMap[node])
      {
         answer += interactionNode->calcA(point);
      }

      result.emplace_back(point, answer / (4.0 * math::PI));
   }

   return result;
}


void FastMultipoleSolver::propagateLocalExpansionsWithComplexTranslation()
{
   _calculationPointOctreeRoot->propagateLocalExpansions();
}

void FastMultipoleSolver::accountFarInteractions()
{
   for(auto& [calcTreeNode, interactionSet] : _farInteractionMap)
   {
      for(auto interactionNode : interactionSet)
      {
         auto translation = interactionNode->box().center() -
            calcTreeNode->box().center();

         auto contributionToLocalExpansion =
            MultipoleTranslator::multipoleToLocalWithComplex(
               interactionNode->multipoleExpansion(),
               translation);

         calcTreeNode->localExpansion().add(
            contributionToLocalExpansion);
      }
   }
}

void FastMultipoleSolver::propagateLocalExpansionsWithMatrices(Device device)
{
   std::vector<std::vector<CalculationPointOctreeNode*>> layers;
   enumerateNodes(_calculationPointOctreeRoot, layers, 0);

   if(log)
   {
      std::cout << std::setw(10) << "layer" << std::setw(15) << "mlpl count";
      std::cout << std::setw(15) << "kernel time" << std::setw(15) << "total time" << std::endl;
      std::cout << "-------------------------------------------------------" << std::endl;
      std::cout << std::fixed;
   }

   calcContributionsToLowerLayers(layers, device);
   //_multipolesAreReady = true;
}

void FastMultipoleSolver::calcContributionsToLowerLayers(
   const std::vector<std::vector<CalculationPointOctreeNode*>>& layers,
   Device device)
{
   for(size_t l = 1; l < layers.size(); l++)
   {
      double kernelTime = 0;

      auto start = std::chrono::steady_clock::now();

      if(log)
      {
         std::cout << std::setw(10) << l << std::setw(15) << layers[l].size();
      }

      auto& layer = layers[l];
      auto nodesByOrientation = separateNodesByOrientation(layer);
      auto regularVectors = calcRegularMatricesForL2LAsVectors(
         nodesByOrientation);

      for(size_t o = 0; o < 8; o++)
      {
         if(!nodesByOrientation[o].empty())
         {
            size_t nodesCount = nodesByOrientation[o].size();

            auto expansionVectors =
               getExpansionsInOneOrientationAsVectors(
                  nodesByOrientation[o]);

            RealMatrix translated(3, std::vector<real>(harmonicLength * nodesCount));

            for(size_t c = 0; c < 3; c++)
            {
               auto kernelStart = std::chrono::steady_clock::now();

               switch(device)
               {
                  case Device::CPU:
                  {
                     kernels::translateAllCPUMatrixBLAS(
                        translated[c].data(),
                        expansionVectors[c].data(),
                        regularVectors[o].data(),
                        nodesCount,
                        harmonicOrder);

                     break;
                  }
                  case Device::GPU:
                  {
                     kernels::translateAllGPUMatrixCuBLAS(
                        translated[c].data(),
                        expansionVectors[c].data(),
                        regularVectors[o].data(),
                        nodesCount,
                        harmonicOrder);

                     break;
                  }
                  default:
                  {
                     throw std::exception("Not implemented!");
                  }
               }

               auto kernelStop = std::chrono::steady_clock::now();
               kernelTime += std::chrono::duration_cast<std::chrono::microseconds>
                  (kernelStop - kernelStart).count() * 1e-6;
            }

            accountContributionsToChildren(
               nodesByOrientation[o],
               translated);
         }
      }

      auto stop = std::chrono::steady_clock::now();
      double layerTime = test::getTime(start, stop);

      if(log)
      {
         std::cout << std::setw(15) << kernelTime;
         std::cout << std::setw(15) << layerTime << std::endl;
      }
   }
}

void FastMultipoleSolver::accountContributionsToChildren(
   const std::vector<CalculationPointOctreeNode*>& nodesByOrientation,
   const RealMatrix& contributions)
{
   for(int nodeId = 0; nodeId < nodesByOrientation.size(); nodeId++)
   {
      for(size_t c = 0; c < 3; c++)
      {
         blas::addVectorToVector(
            harmonicLength, 1,
            contributions[c].data() + harmonicLength * nodeId, 1,
            (real*)(nodesByOrientation[nodeId]->localExpansion().data().data()) + c, 3);
      }
   }
}

RealMatrix FastMultipoleSolver::getExpansionsInOneOrientationAsVectors(
   const std::vector<CalculationPointOctreeNode*>& nodesByOrientation) const
{
   size_t nodeCount = nodesByOrientation.size();

   RealMatrix res(3, std::vector<real>(harmonicLength * nodeCount));

   for(int nodeId = 0; nodeId < nodesByOrientation.size(); nodeId++)
   {
      auto& expansion = nodesByOrientation[nodeId]->parent()->localExpansion();

      for(size_t c = 0; c < 3; c++)
      {
         blas::copyVector(
            harmonicLength,
            (real*)expansion.data().data() + c, 3,
            res[c].data() + nodeId * harmonicLength, 1);
      }
   }

   return res;
}

void FastMultipoleSolver::enumerateNodes(
   QuadratureOctreeNode* node,
   std::vector<std::vector<QuadratureOctreeNode*>>& layers,
   size_t currentLayerId)
{
   MultipoleSolver::enumerateNodes(node, layers, currentLayerId);
}

void FastMultipoleSolver::enumerateNodes(
   CalculationPointOctreeNode* node,
   std::vector<std::vector<CalculationPointOctreeNode*>>& layers,
   size_t currentLayerId)
{
   if(node->isSubdivided() || node->isUsefullLeaf())
   {
      if(layers.size() <= currentLayerId)
         layers.push_back(std::vector<CalculationPointOctreeNode*>());

      layers[currentLayerId].push_back(node);

      for(auto child : node->children())
      {
         enumerateNodes(child, layers, currentLayerId + 1);
      }
   }
}

Matrix<QuadratureOctreeNode*> FastMultipoleSolver::separateNodesByOrientation(
   const std::vector<QuadratureOctreeNode*>& layer)
{
   return MultipoleSolver::separateNodesByOrientation(layer);
}

Matrix<CalculationPointOctreeNode*> FastMultipoleSolver::separateNodesByOrientation(
   const std::vector<CalculationPointOctreeNode*>& layer)
{
   Matrix<CalculationPointOctreeNode*> res(8);

   /*for(auto node : layer)
   {
      if(node->isSubdivided())
      {
         for(size_t i = 0; i < 8; i++)
         {
            auto child = node->children()[i];

            if(child->isSubdivided() ||
               child->isUsefullLeaf())
            {
               res[i].push_back(node);
            }
         }
      }
   }*/

   for(auto node : layer)
   {
      for(size_t i = 0; i < 8; i++)
      {
         if(node->parent()->children()[i] == node)
         {
            res[i].push_back(node);
            break;
         }
      }
   }

   return res;
}

RealMatrix FastMultipoleSolver::calcRegularMatricesForL2LAsVectors(
   const Matrix<CalculationPointOctreeNode*>& nodesByOrientation)
{
   size_t matrixElemCount = harmonicLength * harmonicLength;

   RealMatrix result(8, std::vector<real>(matrixElemCount));

   for(int i = 0; i < 8; i++)
   {
      auto parent = nodesByOrientation[i][0]->parent();

      auto translation = parent->box().center() - 
         nodesByOrientation[i][0]->box().center();

      auto regularHarmonics = Harmonics::calcRegularSolidHarmonics(
         harmonicOrder, translation);

      auto regularHarmonicsMatrix = formMatrixFromRegularHarmonicsForL2LAsVectors(
         Harmonics::realToComplex(regularHarmonics));

      Complex alpha = makeComplex(1, 0);
      Complex beta = makeComplex(0, 0);

      std::vector<Complex> temp1(matrixElemCount);

      blas::multComplexMatrices(
         CBLAS_ORDER::CblasRowMajor,
         CBLAS_TRANSPOSE::CblasNoTrans,
         CBLAS_TRANSPOSE::CblasNoTrans,
         harmonicLength, harmonicLength, harmonicLength,
         (real*)&alpha,
         (real*)_realToComplexMatrix.data(),
         harmonicLength,
         (real*)regularHarmonicsMatrix.data(),
         harmonicLength,
         (real*)&beta,
         (real*)temp1.data(),
         harmonicLength);

      std::vector<Complex> temp2(matrixElemCount);

      blas::multComplexMatrices(
         CBLAS_ORDER::CblasRowMajor,
         CBLAS_TRANSPOSE::CblasNoTrans,
         CBLAS_TRANSPOSE::CblasNoTrans,
         harmonicLength, harmonicLength, harmonicLength,
         (real*)&alpha,
         (real*)temp1.data(),
         harmonicLength,
         (real*)_complexToRealMatrix.data(),
         harmonicLength,
         (real*)&beta,
         (real*)temp2.data(),
         harmonicLength);

      blas::copyVector(
         matrixElemCount,
         (real*)(temp2.data()), 2,
         result[i].data(), 1);
   }

   return result;
}

std::vector<Complex> FastMultipoleSolver::formMatrixFromRegularHarmonicsForL2LAsVectors(
   const ComplexHarmonicSeries& regular) const
{
   std::vector<Complex> res(harmonicLength * harmonicLength);

   for(int l = 0; l <= regular.order(); l++)
   {
      for(int m = -l; m <= l; m++)
      {
         for(int lambda = 0; lambda <= l; lambda++)
         {
            int dl = lambda - l;

            for(int mu = -lambda; mu <= lambda; mu++)
            {
               int dm = m - mu;

               if(-dl <= dm && dm <= dl && dl <= harmonicOrder)
               {
                  res[(l * l + l + m) + (lambda * lambda + lambda + mu) * harmonicLength] =
                     regular.getHarmonic(dl * dl + dl + dm) *
                     MultipoleTranslator::localTranslationFactor(m, mu, lambda, l);
               }
            }
         }
      }
   }

   return res;
}
#pragma once
#include <map>
#include <vector>
#include "multipole_solver.hpp"
#include "vector3.cuh"
#include "basis_quadratures.hpp"
#include "quadrature.hpp"
#include "calculation_point_octree.hpp"
#include "multipole_solver_enums.hpp"

typedef std::map<CalculationPointOctreeNode*, std::set<QuadratureOctreeNode*>> InteractionMap;

class FastMultipoleSolver : public MultipoleSolver
{
private:
   std::vector<Vector3>& _points;
   CalculationPointOctreeNode* _calculationPointOctreeRoot = nullptr;
   bool _localMultipolesAreInitialized = false;
   InteractionMap _farInteractionMap;
   InteractionMap _closeInteractionMap;

public:
   const size_t calculationPointOctreeLeafCapacity;

   FastMultipoleSolver(
      std::vector<Quadrature>& quadratures,
      std::vector<Vector3>& points,
      Problem problem = Problem::BioSavartLaplace,
      size_t quadratureOctreeLeafCapacity = 1000,
      size_t calculationPointOctreeLeafCapacity = 100);

   FastMultipoleSolver(
      std::vector<BEMQuadrature>& quadratures,
      std::vector<Vector3>& points,
      Problem problem = Problem::BioSavartLaplace,
      size_t quadratureOctreeLeafCapacity = 1000,
      size_t calculationPointOctreeLeafCapacity = 100);
   
   void calcLocalMultipoleExpansions(
      M2LAlg algorithm,
      Device device = Device::CPU);
   
   virtual Vector3 calcA(real current, const Vector3& point) override;
   virtual Vector3 calcB(real current, const Vector3& point) override;
   virtual std::vector<std::pair<Vector3, Vector3>> calcA(real current);
   virtual std::vector<std::pair<Vector3, Vector3>> calcB(real current);
   virtual std::vector<std::pair<Vector3, Vector3>> calcBEM(real current);

   virtual ~FastMultipoleSolver() override;

private:
   void initTrees() override;
   void propagateLocalExpansionsWithComplexTranslation();
   void propagateLocalExpansionsWithMatrices(Device device);

   void formInteractionMaps(
      QuadratureOctreeNode* quadratureTreeNode,
      CalculationPointOctreeNode* calcPointTreeNode);

   bool checkIfFarEnough(
      const QuadratureOctreeNode* quadratureTreeNode,
      const CalculationPointOctreeNode* calcPointTreeNode) const;

   void accountFarInteractions();

   void calcContributionsToLowerLayers(
      const std::vector<std::vector<CalculationPointOctreeNode*>>& layers,
      Device device);

   void accountContributionsToChildren(
      const std::vector<CalculationPointOctreeNode*>& nodesByOrientation,
      const RealMatrix& contributions);

   RealMatrix getExpansionsInOneOrientationAsVectors(
      const std::vector<CalculationPointOctreeNode*>& nodesByOrientation) const;

   virtual void enumerateNodes(
      QuadratureOctreeNode* node,
      std::vector<std::vector<QuadratureOctreeNode*>>& layers,
      size_t currentLayerId) override;

   virtual void enumerateNodes(
      CalculationPointOctreeNode* node,
      std::vector<std::vector<CalculationPointOctreeNode*>>& layers,
      size_t currentLayerId);

   virtual Matrix<QuadratureOctreeNode*> separateNodesByOrientation(
      const std::vector<QuadratureOctreeNode*>& layer) override;

   Matrix<CalculationPointOctreeNode*> separateNodesByOrientation(
      const std::vector<CalculationPointOctreeNode*>& layer);

   RealMatrix calcRegularMatricesForL2LAsVectors(
      const Matrix<CalculationPointOctreeNode*>& nodesByOrientation);

   std::vector<Complex> formMatrixFromRegularHarmonicsForL2LAsVectors(
      const ComplexHarmonicSeries& regular) const;
};#include <thrust/complex.h>
#include <limits>
#include "harmonics.hpp"
#include "math.hpp"
#include <iostream>

Factorials Harmonics::_factorials;

Harmonics::Harmonics(size_t order, const Vector3& point) :
   _order(order)
{
   calcSphericalHarmonics(point);
}

const RealHarmonicSeries& Harmonics::sphericalHarmonics() const
{
   return _sphericalHarmonics;
}

RealHarmonicSeries Harmonics::calcSolidHarmonics(size_t order,
                                                   Vector3 point,
                                                   bool isRegular)
{
#if defined REAL_IS_DOUBLE
   real r = point.length() + std::numeric_limits<double>::epsilon();
#endif // !REAL_IS_DOUBLE
#if defined REAL_IS_FLOAT
   real r = point.length() + std::numeric_limits<float>::epsilon();
#endif // !REAL_IS_FLOAT

   point /= r;

   auto solidlHarmonics = Harmonics(order, point).sphericalHarmonics();

   real mult = isRegular ? r : 1 / r;
   real curr = isRegular ? 1 : mult;

   for(int l = 0; l <= order; l++)
   {
      for(int m = 0; m <= l; m++)
      {
         solidlHarmonics.getHarmonic(l, -m) *= curr *
            (isRegular ? 1.0 / _factorials[l + m] : _factorials[l - m]);
      }

      for(int m = 1; m <= l; m++)
      {
         solidlHarmonics.getHarmonic(l, m) *= curr *
            (isRegular ? 1.0 / _factorials[l + m] : _factorials[l - m]);
      }

      curr *= -mult;
   }

   return solidlHarmonics;
}

RealHarmonicSeries Harmonics::calcRegularSolidHarmonics(size_t order, Vector3 point)
{
   return calcSolidHarmonics(order, point, true);
}

RealHarmonicSeries Harmonics::calcIrregularSolidHarmonics(size_t order, Vector3 point)
{
   return calcSolidHarmonics(order, point, false);
}

void Harmonics::calcSphericalHarmonics(const Vector3& point)
{
   _sphericalHarmonics = RealHarmonicSeries(_order);
   fillWithLegendrePolynomials(point.z);
   fillWithLegendrePolynomialDerivatives(point.z);
   mirrorLegendrePolynomialDerivatives(point.z);
   addComplex(point.x, point.y);
}

void Harmonics::fillWithLegendrePolynomials(real z)
{
   _sphericalHarmonics.getHarmonic(0, 0) = 1;
   _sphericalHarmonics.getHarmonic(1, 0) = z;

   for(size_t l = 2; l <= _order; l++)
   {
      _sphericalHarmonics.getHarmonic(l, 0) = calcLegendrePolynomial(l, z);
   }
}

void Harmonics::fillWithLegendrePolynomialDerivatives(real z)
{
   _sphericalHarmonics.getHarmonic(0, 0) = 1;
   _sphericalHarmonics.getHarmonic(1, -1) = 1;
   _sphericalHarmonics.getHarmonic(1, 1) = 1;

   for(size_t l = 2; l <= _order; l++)
   {
      for(size_t m = 1; m < l; m++)
      {
         _sphericalHarmonics.getHarmonic(l, m) = z * _sphericalHarmonics.getHarmonic(l - 1, m) +
            (l + m - 1) * _sphericalHarmonics.getHarmonic(l - 1, m - 1);
      }

      _sphericalHarmonics.getHarmonic(l, l) = (2 * l - 1) *
         _sphericalHarmonics.getHarmonic(l - 1, l - 1);
   }

}

void Harmonics::mirrorLegendrePolynomialDerivatives(real z)
{
   for(int l = 2; l <= _order; l++)
   {
      for(int m = -l; m <= l; m++)
      {
         _sphericalHarmonics.getHarmonic(l, m) = _sphericalHarmonics.getHarmonic(l, -m);
      }
   }
}

real Harmonics::calcLegendrePolynomial(int l, real z)
{
   return ((2 * l - 1) * z * _sphericalHarmonics.getHarmonic(l - 1, 0) -
           (l - 1) * _sphericalHarmonics.getHarmonic(l - 2, 0)) / (l);
}

void Harmonics::addComplex(real x, real y)
{
   Complex ephi1m = makeComplex(sqrt(2.0), 0);
   Complex mult = makeComplex(x, y);

   for(int m = 1; m < _order; m++)
   {
      ephi1m *= mult;

      for(int l = m; l <= _order; l++)
      {
         _sphericalHarmonics.getHarmonic(l, m) *= getReal(ephi1m);
         _sphericalHarmonics.getHarmonic(l, -m) *= getImag(ephi1m);
      }
   }
}

ComplexMatrix Harmonics::calcRealToComplexMatrix2D(size_t order)
{
   size_t harmonicLen = (order + 1) * (order + 1);
   ComplexMatrix res(harmonicLen, std::vector<Complex>(harmonicLen));

   for(int l = 0; l <= order; l++)
   {
      for(int m = -l; m <= l; m++)
      {
         real realPart = HarmonicSeries<real>::getRealFactor(l, m);
         real imagPart = HarmonicSeries<real>::getImagFactor(l, m);

         int realM = abs(m);
         int imagM = -abs(m);

         size_t currentIndex = HarmonicSeries<Complex>::lmToIndex(l, m);
         size_t newRealIndex = HarmonicSeries<Complex>::lmToIndex(l, realM);
         size_t newImagIndex = HarmonicSeries<Complex>::lmToIndex(l, imagM);

         res[newRealIndex][currentIndex] += makeComplex(realPart, 0);
         res[newImagIndex][currentIndex] += makeComplex(0, imagPart);
      }
   }

   return res;
}

ComplexMatrix Harmonics::calcComplexToRealMatrix2D(size_t order)
{
   size_t harmonicLen = (order + 1) * (order + 1);
   ComplexMatrix res(harmonicLen, std::vector<Complex>(harmonicLen));

   for(int l = 0; l <= order; l++)
   {
      res[l * l + l][l * l + l] = makeComplex(1, 0);

      for(int m = 1; m <= l; m++)
      {
         res[l * l + l + m][l * l + l + m] = makeComplex(math::R_SQRT_2, 0);
         res[l * l + l - m][l * l + l + m] = makeComplex(math::R_SQRT_2, 0);

         res[l * l + l + m][l * l + l - m] = makeComplex(0, -math::R_SQRT_2);
         res[l * l + l - m][l * l + l - m] = makeComplex(0, math::R_SQRT_2);
      }
   }

   return res;
}

std::vector<Complex> Harmonics::calcRealToComplexTransitionMatrix1D(size_t order)
{
   size_t harmonicLen = (order + 1) * (order + 1);
   std::vector<Complex> res(harmonicLen * harmonicLen);

   for(int l = 0; l <= order; l++)
   {
      for(int m = -l; m <= l; m++)
      {
         real realPart = HarmonicSeries<real>::getRealFactor(l, m);
         real imagPart = HarmonicSeries<real>::getImagFactor(l, m);

         int realM = abs(m);
         int imagM = -abs(m);

         size_t currentIndex = HarmonicSeries<Complex>::lmToIndex(l, m);
         size_t newRealIndex = HarmonicSeries<Complex>::lmToIndex(l, realM);
         size_t newImagIndex = HarmonicSeries<Complex>::lmToIndex(l, imagM);

         res[newRealIndex * harmonicLen + currentIndex] +=
            makeComplex(realPart, 0);
         res[newImagIndex * harmonicLen + currentIndex] +=
            makeComplex(0, imagPart);
      }
   }

   return res;
}

std::vector<Complex> Harmonics::calcComplexToRealTransitionMatrix1D(size_t order)
{
   size_t harmonicLen = (order + 1) * (order + 1);
   std::vector<Complex> res(harmonicLen * harmonicLen);

   for(int l = 0; l <= order; l++)
   {
      res[(l * l + l) * harmonicLen + (l * l + l)] = makeComplex(1, 0);

      for(int m = 1; m <= l; m++)
      {
         res[(l * l + l + m) * harmonicLen + (l * l + l + m)] =
            makeComplex(math::R_SQRT_2, 0);
         res[(l * l + l - m) * harmonicLen + (l * l + l + m)] =
            makeComplex(math::R_SQRT_2, 0);

         res[(l * l + l + m) * harmonicLen + (l * l + l - m)] =
            makeComplex(0, -math::R_SQRT_2);
         res[(l * l + l - m) * harmonicLen + (l * l + l - m)] =
            makeComplex(0, math::R_SQRT_2);
      }
   }

   return res;
}

real Harmonics::getFactorial(size_t n)
{
   return _factorials[n];
}

RealHarmonicSeries Harmonics::separateCoord(
   const HarmonicSeries<Vector3>& harmonics,
   size_t i)
{
   RealHarmonicSeries res(harmonics.order());

   for(size_t h = 0; h < harmonics.elemCount(); h++)
   {
      res.getHarmonic(h) = harmonics.getHarmonic(h)[i];
   }

   return res;
}

HarmonicSeries<Vector3> Harmonics::createFormXYZ(const RealHarmonicSeries& xs,
                                                 const RealHarmonicSeries& ys,
                                                 const RealHarmonicSeries& zs)
{
   HarmonicSeries<Vector3> res(xs.order());

   for(size_t i = 0; i < xs.elemCount(); i++)
   {
      res.getHarmonic(i) = Vector3(xs.getHarmonic(i), 
                                   ys.getHarmonic(i), 
                                   zs.getHarmonic(i));
   }

   return res;
}

ComplexHarmonicSeries Harmonics::realToComplex(
   const RealHarmonicSeries& harmonics)
{
   ComplexHarmonicSeries res(harmonics.order());
   
   real c = math::R_SQRT_2;
   for(int l = 0; l <= harmonics.order(); l++)
   {
      res.getHarmonic(l, 0) = makeComplex(harmonics.getHarmonic(l, 0), 0);
      for(int m = 1; m <= l; m++)
      {
         res.setHarmonic(l, m, makeComplex(
            harmonics.getHarmonic(l, m) * c,
            harmonics.getHarmonic(l, -m) * c));
         res.setHarmonic(l, -m, makeComplex(
            harmonics.getHarmonic(l, m) * c,
            -harmonics.getHarmonic(l, -m) * c));
      }
   }

   return res;
}

RealHarmonicSeries Harmonics::complexToReal(const ComplexHarmonicSeries& harmonics)
{
   RealHarmonicSeries res(harmonics.order());

   real c = 1.0 / sqrt(2);
   for(int l = 0; l <= harmonics.order(); l++)
   {
      res.getHarmonic(l, 0) = getReal(harmonics.getHarmonic(l, 0));
      for(int m = 1; m <= l; m++)
      {
         res.getHarmonic(l, m) = c * getReal(harmonics.getHarmonic(l, m) + harmonics.getHarmonic(l, -m));
         res.getHarmonic(l, -m) = c * getImag(harmonics.getHarmonic(l, m) - harmonics.getHarmonic(l, -m));
      }
   }

   return res;
}

#pragma once
#include <vector>
#include <thrust/complex.h>
#include "real.hpp"
#include "vector3.cuh"
#include "factorials.hpp"
#include "harmonic_series.hpp"

typedef HarmonicSeries<Complex> ComplexHarmonicSeries;
typedef HarmonicSeries<real> RealHarmonicSeries;

class Harmonics
{
private:
   size_t _order;
   RealHarmonicSeries _sphericalHarmonics;
   static Factorials _factorials;
public:   
   Harmonics(size_t order, const Vector3& point);

   const RealHarmonicSeries& sphericalHarmonics() const;

   static RealHarmonicSeries calcSolidHarmonics(
      size_t order, Vector3 point, bool isRegular);
   static RealHarmonicSeries calcRegularSolidHarmonics(
      size_t order, Vector3 point);
   static RealHarmonicSeries calcIrregularSolidHarmonics(
      size_t order, Vector3 point);

   static ComplexHarmonicSeries realToComplex(
      const RealHarmonicSeries& harmonics);

   static RealHarmonicSeries complexToReal(
      const ComplexHarmonicSeries& harmonics);

   static ComplexMatrix calcRealToComplexMatrix2D(size_t order);
   static ComplexMatrix calcComplexToRealMatrix2D(size_t order);

   static std::vector<Complex> calcRealToComplexTransitionMatrix1D(size_t order);
   static std::vector<Complex> calcComplexToRealTransitionMatrix1D(size_t order);

   static real getFactorial(size_t n);
   
   static RealHarmonicSeries separateCoord(
      const HarmonicSeries<Vector3>& harmonics,
      size_t i);

   static HarmonicSeries<Vector3> createFormXYZ(
      const RealHarmonicSeries& xs,
      const RealHarmonicSeries& ys,
      const RealHarmonicSeries& zs);

private:
   void calcSphericalHarmonics(const Vector3& point);
   void fillWithLegendrePolynomials(real z);
   void fillWithLegendrePolynomialDerivatives(real z);
   void mirrorLegendrePolynomialDerivatives(real z);
   real calcLegendrePolynomial(int i, real z);
   void addComplex(real x, real y);
};#pragma once
#include <vector>
#include "real.hpp"
#include "math.hpp"

template <class T>
struct HarmonicSeries
{
private:
   std::vector<T> _data;
   size_t _order;
public:
   HarmonicSeries();
   explicit HarmonicSeries(size_t order);

   T& getHarmonic(int order);
   const T& getHarmonic(int order) const;

   T& getHarmonic(int l, int m);
   const T& getHarmonic(int l, int m) const;
   void setHarmonic(int l, int m, T value);
   size_t order() const;
   size_t elemCount() const;

   const T& getReal(int l, int m) const;
   const T& getImag(int l, int m) const;

   static T getRealFactor(int l, int m);
   static T getImagFactor(int l, int m);

   std::vector<T>& data();
   const std::vector<T>& data() const;

   static size_t lmToIndex(int l, int m);

   HarmonicSeries<T>(HarmonicSeries<T>&& harmonicSeries) noexcept;
   HarmonicSeries<T>(const HarmonicSeries<T>& harmonicSeries);
   HarmonicSeries<T>& operator=(HarmonicSeries<T>&& harmonicSeries) noexcept;
   HarmonicSeries<T>& operator=(const HarmonicSeries<T>& harmonicSeries);

   HarmonicSeries<T>(std::vector<T>&& harmonicData) noexcept;
   HarmonicSeries<T>(const std::vector<T>& harmonicData);

   void add(const HarmonicSeries<T>& harmonicSeries);
   void subtract(const HarmonicSeries<T>& harmonicSeries);
   T sum() const;

   static T mult(const HarmonicSeries<T>& a, const HarmonicSeries<T>& b);
};

template<class T>
inline HarmonicSeries<T>::HarmonicSeries()
{
}

template<class T>
inline HarmonicSeries<T>::HarmonicSeries(size_t order)
{
   _order = order;
   _data = std::vector<T>((order + 1) * (order + 1));
}

template<class T>
inline T& HarmonicSeries<T>::getHarmonic(int order)
{
   return _data[order];
}

template<class T>
inline const T& HarmonicSeries<T>::getHarmonic(int order) const
{
   return _data[order];
}

template<class T>
inline T& HarmonicSeries<T>::getHarmonic(int l, int m)
{
   return _data[l * l + l + m];
}

template<class T>
inline const T& HarmonicSeries<T>::getHarmonic(int l, int m) const
{
   return _data[l * l + l + m];
}

template<class T>
inline void HarmonicSeries<T>::setHarmonic(int l, int m, T value)
{
   _data[l * l + l + m] = value;
}

template<class T>
inline size_t HarmonicSeries<T>::order() const
{
   return _order;
}

template<class T>
inline size_t HarmonicSeries<T>::elemCount() const
{
   return (_order + 1) * (_order + 1);
}

template<class T>
inline const T& HarmonicSeries<T>::getReal(int l, int m) const
{
   return getHarmonic(l, abs(m)) * 
      (math::R_SQRT_2 * (m != 0) + (m == 0));
}

template<class T>
inline const T& HarmonicSeries<T>::getImag(int l, int m) const
{
   return math::sign(m) * getHarmonic(l, -abs(m)) * math::R_SQRT_2 * (m != 0);
}

template<class T>
inline T HarmonicSeries<T>::getRealFactor(int l, int m)
{
   return math::R_SQRT_2 * (m != 0) + (m == 0);
}

template<class T>
inline T HarmonicSeries<T>::getImagFactor(int l, int m)
{
   return math::sign(m) * math::R_SQRT_2;
}

template<class T>
inline std::vector<T>& HarmonicSeries<T>::data()
{
   return _data;
}

template<class T>
inline const std::vector<T>& HarmonicSeries<T>::data() const
{
   return _data;
}

template<class T>
inline size_t HarmonicSeries<T>::lmToIndex(int l, int m)
{
   return l * l + l + m;
}

template<class T>
inline HarmonicSeries<T>& HarmonicSeries<T>::operator=(
   HarmonicSeries<T>&& harmonicSeries) noexcept
{
   _data = std::move(harmonicSeries._data);
   _order = harmonicSeries._order;
   return *this;
}

template<class T>
inline HarmonicSeries<T>& HarmonicSeries<T>::operator=(
   const HarmonicSeries<T>& harmonicSeries)
{
   _data = harmonicSeries._data;
   _order = harmonicSeries._order;
   return *this;
}

template<class T>
inline void HarmonicSeries<T>::add(
   const HarmonicSeries<T>& harmonicSeries)
{
   for(size_t i = 0; i < _data.size(); i++)
   {
      _data[i] += harmonicSeries._data[i];
   }
}

template<class T>
inline void HarmonicSeries<T>::subtract(
   const HarmonicSeries<T>& harmonicSeries)
{
   for(size_t i = 0; i < _data.size(); i++)
   {
      _data[i] -= harmonicSeries._data[i];
   }
}

template <class T>
T HarmonicSeries<T>::sum() const
{
   T res = 0;

   for(size_t i = 0; i < _data.size(); i++)
   {
      res += _data[i];
   }

   return res;
}

template<class T>
inline HarmonicSeries<T>::HarmonicSeries(
   HarmonicSeries<T>&& harmonicSeries) noexcept
{
   _data = std::move(harmonicSeries._data);
   _order = harmonicSeries._order;
}

template<class T>
inline HarmonicSeries<T>::HarmonicSeries(
   const HarmonicSeries<T>& harmonicSeries)
{
   _data = harmonicSeries._data;
   _order = harmonicSeries._order;
}

template<class T>
inline HarmonicSeries<T>::HarmonicSeries(
   std::vector<T>&& harmonicData) noexcept
{
   _order = sqrt(harmonicData.size() - 1);
   _data = std::move(harmonicData);
}

template<class T>
inline HarmonicSeries<T>::HarmonicSeries(
   const std::vector<T>& harmonicData)
{
   _order = sqrt(harmonicData.size() - 1);
   _data = harmonicData;
}

template <class T>
T HarmonicSeries<T>::mult(
   const HarmonicSeries<T>& a, 
   const HarmonicSeries<T>& b)
{
   T res = 0;

   for(int i = 0; i < a.elemCount(); ++i)
   {
      res += a.getHarmonic(i) * b.getHarmonic(i);
   }

   return res;
}

template<class T1, class T2> T1 mult(
   const HarmonicSeries<T1>& a,
   const HarmonicSeries<T2>& b)
{
   T1 res = 0;

   for(int i = 0; i < a.elemCount(); ++i)
   {
      res += a.getHarmonic(i) * b.getHarmonic(i);
   }

   return res;
}#include "hexahedron.hpp"

Hexahedron::Hexahedron()
{
   points.resize(8);
}

Hexahedron::Hexahedron(std::vector<Vector3> points)
   :points(points)
{

}#pragma once
#include "vector3.cuh"
#include <vector>

class Hexahedron
{
public:
   std::vector<Vector3> points;
   Hexahedron();
   Hexahedron(std::vector<Vector3> points);
};#include "integration.hpp"
#include "harmonics.hpp"
#include "math.hpp"

namespace math
{
   real calcLegendrePolynomial(real x, int n)
   {
      switch(n)
      {
         case 0: return 1;
         case 1: return x;
         default: return ((2 * n - 1) * x * 
                          calcLegendrePolynomial(x, n - 1) + (1 - n) * 
                          calcLegendrePolynomial(x, n - 2)) / (n);
      }
   }

   Vector3 calcVectorFunctionIntegral(
      Vector3(*f)(const Vector3&, const Vector3&),
      const Vector3& point,
      const std::vector<Quadrature>& quadratures)
   {
      Vector3 res = 0;

      for(auto& quadrature : quadratures)
      {
         res += f(point, quadrature) * quadrature.weight;
      }

      return res;
   }

   Vector3 pointFromBasisQuadrature(
      const Tetrahedron& tetrahedron,
      const Vector3& quadr)
   {
      return tetrahedron.a() +
         (tetrahedron.b() - tetrahedron.a()) * quadr.x +
         (tetrahedron.c() - tetrahedron.a()) * quadr.y +
         (tetrahedron.d() - tetrahedron.a()) * quadr.z;
   }

   Vector3 pointFromBasisQuadrature(
      const Triangle& triangle,
      const Vector3& quadr)
   {
      return triangle.a() +
         (triangle.b() - triangle.a()) * quadr.x +
         (triangle.c() - triangle.a()) * quadr.y;
   }


   Vector3 calcAViaSimpleIntegration(
      real current,
      const Vector3& point,
      const std::vector<Tetrahedron>& mesh,
      const BasisQuadratures& basisQuadratures)
   {
      return calcVectorFunctionIntegral(
         simpleIntegrationFunctionForA,
         point, 
         tetrahedraToQuadratures(mesh, basisQuadratures)) / 
         (4 * PI) * current;
   }

   Vector3 simpleIntegrationFunctionForA(
      const Vector3& point,
      const Vector3& integr)
   {
      return integr.perp().normalized() / (point - integr).length();
   }

   Vector3 calcAViaMultipoleMethod(
      real current,
      const Vector3& point,
      const std::vector<Tetrahedron>& mesh,
      const BasisQuadratures& basisQuadratures,
      int harmonicOrder)
   {
      auto quadratures = tetrahedraToQuadratures(mesh, basisQuadratures);
      HarmonicSeries<Vector3> integrals = 
         calcIntegralContribution(quadratures, harmonicOrder);

      auto irregularHarmonics = 
         Harmonics::calcSolidHarmonics(harmonicOrder, point, false);

      Vector3 res;

      for(int l = 0; l <= harmonicOrder; l++)
      {
         for(int m = -l; m <= l; m++)
         {
            res += integrals.getHarmonic(l, m) * irregularHarmonics.getHarmonic(l, m);
         }
      }

      return res / (4.0 * PI) * current;
   }

   Vector3 calcBioSavartLaplace(
      real current,
      const Vector3& point,
      std::vector<Quadrature>& quadratures)
   {
      return calcVectorFunctionIntegral(
         bioSavartLaplaceFunction,
         point,
         quadratures) *
         MU0 / (4 * PI) * current;
   }

   Vector3 bioSavartLaplaceFunction(
      const Vector3& point,
      const Vector3& integr)
   {
      Vector3 diff = point - integr;
      return Vector3::cross(integr.perp().normalized(), (diff)) / 
         pow(diff.length(), 3);
   }

   HarmonicSeries<Vector3> calcIntegralContribution(
      std::vector<Quadrature>& quadratures,
      int harmonicOrder,
      const Vector3& center)
   {
      std::vector<Quadrature*> newQuadratures(quadratures.size());

      for(size_t i = 0; i < quadratures.size(); i++)
      {
         newQuadratures[i] = &quadratures[i];
      }

      return calcIntegralContribution(newQuadratures, harmonicOrder, center);
   }

   HarmonicSeries<Vector3> calcIntegralContribution(
      const std::vector<Quadrature*>& quadratures, 
      int harmonicOrder,
      const Vector3& center)
   {
      HarmonicSeries<Vector3> res(harmonicOrder);

      for(auto quadrature : quadratures)
      {
         auto translation = *quadrature - center;
         auto regularHarmonics = Harmonics::calcSolidHarmonics(
            harmonicOrder,
            translation,
            true);

         for(size_t i = 0; i < regularHarmonics.elemCount(); i++)
         {
            res.getHarmonic(i) +=
               quadrature->perp().normalized() *
               regularHarmonics.getHarmonic(i) * quadrature->weight;
         }
      }

      return res;
   }

   std::vector<Quadrature> tetrahedraToQuadratures(
      const std::vector<Tetrahedron>& mesh,
      const BasisQuadratures& basisQuadratures)
   {
      auto res = std::vector<Quadrature>(mesh.size() * basisQuadratures.order());

      for(size_t t = 0; t < mesh.size(); t++)
      {
         real volume = mesh[t].volume();

         for(size_t i = 0; i < basisQuadratures.order(); i++)
         {
            Vector3 quadrature = math::pointFromBasisQuadrature(
               mesh[t],
               basisQuadratures.values(i));

            res[t * basisQuadratures.order() + i] = Quadrature(
               quadrature,
               volume,
               basisQuadratures.w(i));
         }
      }

      return res;
   }

#pragma region BEM problem

   Vector3 BEMFunction(
      const Vector3& point,
      const BEMQuadrature& quadrature)
   {
      Vector3 diff = quadrature - point;
      real length3 = std::pow<real>(diff.length(), 3);
      Vector3 first = diff * Vector3::dot(quadrature.B, quadrature.normal);
      Vector3 second = Vector3::cross(diff,Vector3::cross(quadrature.B, quadrature.normal));

      return (first + second) / length3;
   }

   Vector3 calcBEMIntegral(
      const Vector3& point,
      const std::vector<BEMQuadrature>& quadratures)
   {
      Vector3 res = 0;

      for(auto& quadrature : quadratures)
      {
         res += BEMFunction(point, quadrature) * quadrature.weight;
      }

      return res / (4 * PI);
   }

   std::vector<BEMQuadrature> calcBEMquadraturesFromTriangles(
      const std::vector<Triangle>& triangles,
      const BasisQuadratures& basisQuadratures,
      const std::vector<ReferenceCylinderData>& referenceCylinderData,
      int normalDir)
   {
      std::vector<BEMQuadrature> result;
      result.reserve(basisQuadratures.order() * triangles.size());

      for (auto triangle : triangles)
      {
         Triangle triangleCartesian = Triangle(
            math::cylindricToCartesian(triangle.a()),
            math::cylindricToCartesian(triangle.b()),
            math::cylindricToCartesian(triangle.c()));
         
         Vector3 B;
         Vector3 closestB;
         real minDist = 1000000;

         Box triangleBoundingBox = triangleCartesian.boundingBox();

         for (const auto & cylinderData : referenceCylinderData)
         {
            if(triangleBoundingBox.contains(cylinderData.point))
            {
               B = cylinderData.B;
               break;
            }
            else
            {
               real dist;

               if((dist = Vector3::distanceSquared(cylinderData.point, triangleCartesian.center())) < 
                  minDist * minDist)
               {
                  closestB = cylinderData.B;
                  minDist = dist;
               }
            }
         }

         if(B.x == 0 && B.y == 0 && B.z == 0)
            B = closestB;

         for(size_t q = 0; q < basisQuadratures.order(); q++)
         {
            auto pointFromBasisQuadratureCylindric = math::pointFromBasisQuadrature(
               triangle, basisQuadratures.values(q));

            Vector3 pointFromBasisQuadrature = math::cylindricToCartesian(
               pointFromBasisQuadratureCylindric);

            Vector3 normal;

            if(normalDir == 0)
            {
               normal = pointFromBasisQuadrature;
               normal.z = 0;
               normal.normalize();
            }
            else
            {
               normal = Vector3::zAxis() * normalDir;
            }

            result.emplace_back(
               pointFromBasisQuadrature,
               triangle.area() * pointFromBasisQuadratureCylindric.y,
               basisQuadratures.w(q),
               B,
               normal);
         }
      }

      return result;
   }

   HarmonicSeries<Vector3> calcBEMIntegralContribution(
      const std::vector<Quadrature*>& quadratures,
      int harmonicOrder,
      const Vector3& center)
   {
      HarmonicSeries<Vector3> res(harmonicOrder);

      for(auto quadrature : quadratures)
      {
         auto translation = *quadrature - center;

         auto hx1 = Harmonics::calcRegularSolidHarmonics(
            harmonicOrder,
            translation + Vector3::xAxis() * math::eps);

         auto hx2 = Harmonics::calcRegularSolidHarmonics(
            harmonicOrder,
            translation - Vector3::xAxis() * math::eps);

         auto hy1 = Harmonics::calcRegularSolidHarmonics(
            harmonicOrder,
            translation + Vector3::yAxis() * math::eps);

         auto hy2 = Harmonics::calcRegularSolidHarmonics(
            harmonicOrder,
            translation - Vector3::yAxis() * math::eps);

         auto hz1 = Harmonics::calcRegularSolidHarmonics(
            harmonicOrder,
            translation + Vector3::zAxis() * math::eps);

         auto hz2 = Harmonics::calcRegularSolidHarmonics(
            harmonicOrder,
            translation - Vector3::zAxis() * math::eps);

         hx1.subtract(hx2);
         hy1.subtract(hy2);
         hz1.subtract(hz2);

         auto bemQuadrature = reinterpret_cast<BEMQuadrature*>(quadrature);

         for(size_t i = 0; i < hx1.elemCount(); i++)
         {
            Vector3 gradR = Vector3(
               hx1.getHarmonic(i),
               hy1.getHarmonic(i),
               hz1.getHarmonic(i)) / (2 * math::eps);

            Vector3 first = gradR * Vector3::dot(bemQuadrature->B, bemQuadrature->normal);
            Vector3 second = Vector3::cross(
               gradR,
               Vector3::cross(bemQuadrature->B, bemQuadrature->normal));

            res.getHarmonic(i) -= (first + second) * bemQuadrature->weight;
         }
      }

      return res;
   }

   real calcSurfaceArea(const std::vector<BEMQuadrature>& quadratures)
   {
      real result = 0;

      for(auto& quadrature : quadratures)
      {
         result += quadrature.weight;
      }

      return result;
   }

#pragma endregion
}#pragma once
#include "real.hpp"
#include "vector3.cuh"
#include "tetrahedron.hpp"
#include "basis_quadratures.hpp"
#include "bem_quadrature.hpp"
#include "quadrature.hpp"
#include "harmonic_series.hpp"
#include "reference_cylinder_data.hpp"
#include "triangle.hpp"

namespace math
{
   real calcLegendrePolynomial(real x, int n);

   Vector3 calcVectorFunctionIntegral(
      Vector3(*f)(const Vector3&, const Vector3&),
      const Vector3& point,
      const std::vector<Quadrature>& quadratures);

   Vector3 pointFromBasisQuadrature(
      const Tetrahedron& tetrahedron,
      const Vector3& quadr);

   Vector3 pointFromBasisQuadrature(
      const Triangle& triangle,
      const Vector3& quadr);

   Vector3 calcAViaSimpleIntegration(
      real current,
      const Vector3& point,
      const std::vector<Tetrahedron>& mesh,
      const BasisQuadratures& basisQuadratures);

   Vector3 simpleIntegrationFunctionForA(
      const Vector3& point,
      const Vector3& integr);

   Vector3 calcAViaMultipoleMethod(
      real current,
      const Vector3& point,
      const std::vector<Tetrahedron>& mesh,
      const BasisQuadratures& basisQuadratures,
      int harmonicOrder);

   Vector3 calcBioSavartLaplace(
      real current,
      const Vector3& point,
      std::vector<Quadrature>& quadratures);

   Vector3 bioSavartLaplaceFunction(
      const Vector3& point,
      const Vector3& integr);
   
   HarmonicSeries<Vector3> calcIntegralContribution(
      std::vector<Quadrature>& quadratures,
      int harmonicOrder,
      const Vector3& center = Vector3());

   HarmonicSeries<Vector3> calcIntegralContribution(
      const std::vector<Quadrature*>& quadratures,
      int harmonicOrder,
      const Vector3& center = Vector3());

   std::vector<Quadrature> tetrahedraToQuadratures(
      const std::vector<Tetrahedron>& mesh,
      const BasisQuadratures& basisQuadratures);

#pragma region BEM problem

   Vector3 BEMFunction(
      const Vector3& point,
      const BEMQuadrature& quadrature);

   Vector3 calcBEMIntegral(
      const Vector3& point,
      const std::vector<BEMQuadrature>& quadratures);
   
   std::vector<BEMQuadrature> calcBEMquadraturesFromTriangles(
      const std::vector<Triangle>& triangles,
      const BasisQuadratures& basisQuadratures,
      const std::vector<ReferenceCylinderData>& referenceCylinderData,
      int normalDir);

   HarmonicSeries<Vector3> calcBEMIntegralContribution(
      const std::vector<Quadrature*>& quadratures,
      int harmonicOrder,
      const Vector3& center = Vector3());

   real calcSurfaceArea(const std::vector<BEMQuadrature>& quadratures);
   
#pragma endregion
}﻿#include "kernels.cuh"
#include <stdio.h>
#include <thrust/complex.h>

namespace kernels
{
   __global__ void translateAllGPUKernelSimpleXY(
      Vector3* result, const real* a, const Vector3* b,
      size_t harmonicCount, size_t harmonicOrder)
   {
      size_t harmonicLength = (harmonicOrder + 1) * (harmonicOrder + 1);
      uint harmonicId = blockIdx.x * blockDim.x + threadIdx.x;

      if(harmonicId < harmonicCount)
      {
         size_t harmonicBegin = harmonicLength * harmonicId;

         Vector3 zeroRes = 0;
         size_t l = threadIdx.y;

         for(int lambda = 0; lambda <= l; lambda++)
         {
            int dl = l - lambda;

            for(int mu = -lambda; mu <= lambda; mu++)
            {
               if(-dl <= mu && mu <= +dl)
               {
                  zeroRes += b[lmToIndex(harmonicBegin, lambda, mu)] *
                     a[lmToIndex(harmonicBegin, dl, mu)] *
                     strangeFactor(0, mu);
               }
            }
         }

         result[lmToIndex(harmonicBegin, l, 0)] = zeroRes;

         for(int m = 1; m <= l; m++)
         {
            Vector3 realRes = 0;
            Vector3 imagRes = 0;

            for(int lambda = 0; lambda <= l; lambda++)
            {
               int dl = l - lambda;

               for(int mu = -lambda; mu <= lambda; mu++)
               {
                  int dm = m - mu;
                  int dnm = -m - mu;

                  Vector3 RR = getReal(b, harmonicBegin, lambda, mu);
                  Vector3 IR = getImag(b, harmonicBegin, lambda, mu);

                  real RM = 0;
                  real IM = 0;

                  real RnM = 0;
                  real InM = 0;

                  if(-dl <= dm && dm <= dl)
                  {
                     RM = getReal(a, harmonicBegin, dl, dm);
                     IM = getImag(a, harmonicBegin, dl, dm);

                     realRes += (RR * RM - IR * IM) * strangeFactor(m, mu);
                     imagRes += (RR * IM + IR * RM) * strangeFactor(m, mu);
                  }

                  if(-dl <= dnm && dnm <= dl)
                  {
                     RnM = getReal(a, harmonicBegin, dl, dnm);
                     InM = getImag(a, harmonicBegin, dl, dnm);

                     realRes += (RR * RnM - IR * InM) * strangeFactor(-m, mu);
                     imagRes -= (RR * InM + IR * RnM) * strangeFactor(-m, mu);
                  }
               }
            }

            result[lmToIndex(harmonicBegin, l, m)] = realRes * math::R_SQRT_2;
            result[lmToIndex(harmonicBegin, l, -m)] = imagRes * math::R_SQRT_2;
         }
      }
   }

   __global__ void matMulKernel(
      ComplexKernelMatrix A,
      ComplexKernelMatrix B,
      ComplexKernelMatrix C)
   {
   //   int blockRow = blockIdx.y;
   //   int blockCol = blockIdx.x;

   //   ComplexKernelMatrix Csub = getSubMatrix(C, blockRow, blockCol);
   //   Complex Cvalue = make_cuComplex(0, 0);

   //   int row = threadIdx.y;
   //   int col = threadIdx.x;

   //   for(int m = 0; m < (A.width / THREADS_PER_BLOCK); ++m)
   //   {
   //      ComplexKernelMatrix Asub = getSubMatrix(A, blockRow, m);
   //      ComplexKernelMatrix Bsub = getSubMatrix(B, m, blockCol);

   //      __shared__ Complex As[THREADS_PER_BLOCK][THREADS_PER_BLOCK];
   //      __shared__ Complex Bs[THREADS_PER_BLOCK][THREADS_PER_BLOCK];

   //      As[row][col] = getElement(Asub, row, col);
   //      Bs[row][col] = getElement(Bsub, row, col);

   //      __syncthreads();

   //      for(int e = 0; e < THREADS_PER_BLOCK; ++e)
   //         Cvalue = Cvalue + As[row][e] * Bs[e][col];

   //      __syncthreads();
   //   }

   //   setElement(Csub, row, col, Cvalue);
   }
}#include "cuda_runtime.h"
#include "cublas_v2.h"
#include "device_launch_parameters.h"
#include "harmonics.hpp"

namespace kernels
{
   constexpr uint THREADS_PER_BLOCK = 32;
   constexpr uint HARMONIC_ORDER = 10;
   constexpr uint HARMONIC_LENGTH = 121;

   template<class T>
   __global__ void addingKernel(T* c, const T* a, const T* b)
   {
      uint i = threadIdx.x;
      c[i] = a[i] + b[i];
   }

   __global__ void translateAllGPUKernelSimpleXY(
      Vector3* result, const real* a, const Vector3* b,
      size_t harmonicCount, size_t harmonicOrder);

   template <class T>
   struct KernelMatrix
   {
      int width;
      int height;
      int stride;
      T* elements;
   };

   typedef KernelMatrix<Complex> ComplexKernelMatrix;

   template<class T>
   __device__ T getElement(const KernelMatrix<T> A, int row, int col)
   {
      return A.elements[row * A.stride + col];
   }

   template<class T>
   __device__ void setElement(KernelMatrix<T> A, int row, int col,
                              T value)
   {
      A.elements[row * A.stride + col] = value;
   }

   template<class T>
   __device__ KernelMatrix<T> getSubMatrix(KernelMatrix<T> A, int row, int col)
   {
      KernelMatrix<T> Asub;
      Asub.width = THREADS_PER_BLOCK;
      Asub.height = THREADS_PER_BLOCK;
      Asub.stride = A.stride;
      Asub.elements = &A.elements[A.stride * THREADS_PER_BLOCK * row
         + THREADS_PER_BLOCK * col];
      return Asub;
   }

   __global__ void matMulKernel(
      ComplexKernelMatrix A,
      ComplexKernelMatrix B,
      ComplexKernelMatrix C);

   __all__ size_t lmToIndex(int harmonicBegin,
                    int l, int m);

   __all__ size_t lmToIndex(int l, int m);

   template <typename T>
   __all__ T& getHarmonic(T* harmonics,
                  int harmonicBegin,
                  int l, int m)
   {
      return harmonics[harmonicBegin + l * l + l + m];
   }

   template <typename T>
   __all__ T& getHarmonic(T* harmonics,
                          int l, int m)
   {
      return harmonics[l * l + l + m];
   }

   template <typename T>
   __all__ T getReal(const T* harmonics,
             int harmonicBegin,
             int l, int m)
   {
      return harmonics[lmToIndex(harmonicBegin, l, abs(m))] *
         (math::R_SQRT_2 * (m != 0) + (m == 0));
   }

   template <typename T>
   __all__ T getReal(const T* harmonics,
                     int l, int m)
   {
      return harmonics[lmToIndex(l, abs(m))] *
         (math::R_SQRT_2 * (m != 0) + (m == 0));
   }

   template <typename T>
   __all__ T getImag(const T* harmonics,
             int harmonicBegin,
             int l, int m)
   {
     return harmonics[lmToIndex(harmonicBegin, l, -abs(m))] *
         math::R_SQRT_2 * (m != 0) * math::sign(m);
   }

   template <typename T>
   __all__ T getImag(const T* harmonics,
                     int l, int m)
   {
      return harmonics[lmToIndex(l, -abs(m))] *
         math::R_SQRT_2 * (m != 0) * math::sign(m);
   }

   __all__ real strangeFactor(int m, int mu);
}﻿#include <cublas_v2.h>
#include <iostream>
#include <string>
#include <fstream>
#include <iomanip>
#include <ostream>
#include <sstream>

#include "cblas.h"
#include "cylinder.hpp"
#include "dev_ptr.hpp"
#include "exeptions.hpp"
#include "vector3.cuh"
#include "math.hpp"
#include "integration.hpp"
#include "harmonics.hpp"
#include "multipole_solver.hpp"
#include "fast_multipole_solver.hpp"
#include "translation_algorithms.hpp"
#include "testing_helpers.hpp"
#include "multipole_translator.hpp"
#include "blass_callers.hpp"

using namespace math;
using namespace test;
constexpr real current = 5;

std::vector<std::pair<Vector3, Vector3>> readTelmaResults(const std::string& filename)
{
   std::vector<std::pair<Vector3, Vector3>> res;
   std::ifstream fin(filename);
   size_t pointsCount;
   std::string _;
   fin >> _ >> _ >> _;
   fin >> pointsCount;
   res.resize(pointsCount);

   for(size_t i = 0; i < pointsCount; i++)
   {
      real px, py, pz, hx, hy, hz;
      
      fin >> _ >> px >> py >> pz >> hx >> hy >> hz;

      res[i] = std::pair<Vector3, Vector3>(Vector3(px, py, pz), Vector3(hx, hy, hz));
   }

   return res;
}

void comparisonToTelmaIntegrals()
{
   Torus torus = createTorus();
   BasisQuadratures bq = readTetrahedronBasisQuadratures();
   auto telmaResults = readTelmaResults("results/telma_results.txt");
   auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);

   std::vector<Vector3> initialPoints(telmaResults.size());

   for(size_t i = 0; i < telmaResults.size(); i++)
   {
      initialPoints[i] = telmaResults[i].first;
   }

   //MultipoleSolver multipoleSolverNoExp(quadratures);
   //MultipoleSolver multipoleSolverComplex(quadratures);
   //MultipoleSolver multipoleSolverReal(quadratures);
   //MultipoleSolver multipoleSolverLayersCPU(quadratures);
   //MultipoleSolver multipoleSolverLayersGPU(quadratures);
   MultipoleSolver multipoleSolverMatricesCPU(quadratures);
   MultipoleSolver multipoleSolverMatricesGPU(quadratures);

   //FastMultipoleSolver fmmSolver(quadratures, initialPoints, Problem::BioSavartLaplace, 1000, 32);

   //multipoleSolverNoExp.calclMultipoleExpansions(M2MAlg::NoTranslation);
   //multipoleSolverComplex.calclMultipoleExpansions(M2MAlg::ComplexTranslation);
   //multipoleSolverReal.calclMultipoleExpansions(M2MAlg::RealTranslation);
   //multipoleSolverLayersCPU.calclMultipoleExpansions(M2MAlg::Layers, Device::CPU);
   //multipoleSolverLayersGPU.calclMultipoleExpansions(M2MAlg::Layers, Device::GPU);
   multipoleSolverMatricesCPU.calclMultipoleExpansions(M2MAlg::Matrices, Device::CPU);
   multipoleSolverMatricesGPU.calclMultipoleExpansions(M2MAlg::Matrices, Device::GPU);

   //fmmSolver.calclMultipoleExpansions(M2MAlg::Matrices, Device::GPU);
   //fmmSolver.calcLocalMultipoleExpansions(M2LAlg::ComplexTranslation, Device::CPU);

   //auto points = fmmSolver.calcB(current);

   //real sumErrorIntegration = 0;
   //real sumErrorNoTranslation = 0;
   //real sumErrorComplexTranslation = 0;
   //real sumErrorRealTranslation = 0;
   //real sumErrorLayersTranslationCPU = 0;
   //real sumErrorLayersTranslationGPU = 0;
   real sumErrorMatricesTranslationCPU = 0;
   real sumErrorMatricesTranslationGPU = 0;
   //real sumFmmSolver = 0;

   size_t n = telmaResults.size();

   for(size_t i = 0; i < n; i++)
   {
      //auto point = points[i].first;
      //Vector3 telmaB;

      //for(size_t j = 0; j < n; j++)
      //{
      //   if(point.x == telmaResults[j].first.x &&
      //      point.y == telmaResults[j].first.y &&
      //      point.z == telmaResults[j].first.z)
      //   {
      //      telmaB = telmaResults[j].second * math::MU0;
      //      break;
      //   }
      //}

      auto point = telmaResults[i].first;
      auto telmaB = telmaResults[i].second * math::MU0;

     /* Vector3 integration = math::calcBioSavartLaplace(current, point, quadratures);
      Vector3 noTranslation = multipoleSolverNoExp.calcB(current, point);
      Vector3 complexTranslation = multipoleSolverComplex.calcB(current, point);
      Vector3 realTranslation = multipoleSolverReal.calcB(current, point);
      Vector3 layersTranslationCPU = multipoleSolverLayersCPU.calcB(current, point);
      Vector3 layersTranslationGPU = multipoleSolverLayersGPU.calcB(current, point);*/
      Vector3 matricesTranslationCPU = multipoleSolverMatricesCPU.calcB(current, point);
      Vector3 matricesTranslationGPU = multipoleSolverMatricesGPU.calcB(current, point);

      //real errorIntegration = 100 * (integration - telmaB).length() / telmaB.length();
      //real errorNoTranslation = 100 * (noTranslation - telmaB).length() / telmaB.length();
      //real errorComplexTranslation = 100 * (complexTranslation - telmaB).length() / telmaB.length();
      //real errorRealTranslation = 100 * (realTranslation - telmaB).length() / telmaB.length();
      //real errorLayersTranslationCPU = 100 * (layersTranslationCPU - telmaB).length() / telmaB.length();
      //real errorLayersTranslationGPU = 100 * (layersTranslationGPU - telmaB).length() / telmaB.length();
      real errorMatricesTranslationCPU = 100 * (matricesTranslationCPU - telmaB).length() / telmaB.length();
      real errorMatricesTranslationGPU = 100 * (matricesTranslationGPU - telmaB).length() / telmaB.length();
      //real errorFmm = 100 * (points[i].second - telmaB).length() / telmaB.length();

      std::cout << std::fixed << std::setw(3) << i << " ";
      point.printWithWidth(std::cout, 6);
      //std::cout << std::setw(16) << errorIntegration;
      //std::cout << std::setw(16) << errorNoTranslation;
      //std::cout << std::setw(16) << errorComplexTranslation;
      //std::cout << std::setw(16) << errorRealTranslation;
      //std::cout << std::setw(16) << errorLayersTranslationCPU;
      //std::cout << std::setw(16) << errorLayersTranslationGPU;
      std::cout << std::setw(16) << errorMatricesTranslationCPU;
      std::cout << std::setw(16) << errorMatricesTranslationGPU;
      //std::cout << std::setw(16) << errorFmm;
      std::cout << std::endl;

      //sumErrorIntegration += errorIntegration;
      //sumErrorNoTranslation += errorNoTranslation;
      //sumErrorComplexTranslation += errorComplexTranslation;
      //sumErrorRealTranslation += errorRealTranslation;
      //sumErrorLayersTranslationCPU += errorLayersTranslationCPU;
      //sumErrorLayersTranslationGPU += errorLayersTranslationGPU;
      sumErrorMatricesTranslationCPU += errorMatricesTranslationCPU;
      sumErrorMatricesTranslationGPU += errorMatricesTranslationGPU;
      //sumFmmSolver += errorFmm;
   }

   //std::cout << sumErrorIntegration / n << std::endl;
   //std::cout << sumErrorNoTranslation / n << std::endl;
   //std::cout << sumErrorComplexTranslation / n << std::endl;
   //std::cout << sumErrorRealTranslation / n << std::endl;
   //std::cout << sumErrorLayersTranslationCPU / n << std::endl;
   //std::cout << sumErrorLayersTranslationGPU / n << std::endl;
   std::cout << sumErrorMatricesTranslationCPU / n << std::endl;
   std::cout << sumErrorMatricesTranslationGPU / n << std::endl;
   //std::cout << sumFmmSolver / n << std::endl;
}

void comparisonBetweenMethodsOnPrecision()
{
   Torus torus = createTorus();
   BasisQuadratures bq = readTetrahedronBasisQuadratures();
   auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);
   MultipoleSolver multipoleSolver(quadratures, Problem::BioSavartLaplace, 10);
   multipoleSolver.log = false;
   multipoleSolver.calcMultipoleExpansionsAtLeaves();

   Vector3 point(10, 5, 8);

   Vector3 byIntegration = math::calcBioSavartLaplace(current, point, quadratures);
   
   multipoleSolver.calclMultipoleExpansions(M2MAlg::NoTranslation);
   Vector3 byMultipolesWithoutTranslation = multipoleSolver.calcB(current, point);

   multipoleSolver.calclMultipoleExpansions(M2MAlg::ComplexTranslation);
   Vector3 byMultipolesWithComplexTranslation = multipoleSolver.calcB(current, point);

   multipoleSolver.calclMultipoleExpansions(M2MAlg::RealTranslation);
   Vector3 byMultipolesWithRealTranslation = multipoleSolver.calcB(current, point);

   multipoleSolver.calclMultipoleExpansions(M2MAlg::Layers);
   Vector3 byMultipolesWithLayersCPU = multipoleSolver.calcB(current, point);

   multipoleSolver.calclMultipoleExpansions(M2MAlg::Layers, Device::GPU);
   Vector3 byMultipolesWithLayersGPU = multipoleSolver.calcB(current, point);

   multipoleSolver.calclMultipoleExpansions(M2MAlg::Matrices, Device::CPU);
   Vector3 byMultipolesWithMatricesCPU = multipoleSolver.calcB(current, point);

   multipoleSolver.calclMultipoleExpansions(M2MAlg::Matrices, Device::GPU);
   Vector3 byMultipolesWithMatricesGPU = multipoleSolver.calcB(current, point);

   std::cout << std::setw(20) << "point ";
   point.printWithWidth(std::cout, 6);
   std::cout << std::scientific << std::endl;
   std::cout << std::setw(40) << "integration " << byIntegration << std::endl;
   std::cout << std::setw(40) << "multipoles w/t translation " << byMultipolesWithoutTranslation << std::endl;
   std::cout << std::setw(40) << "multipoles with c translation " << byMultipolesWithComplexTranslation << std::endl;
   std::cout << std::setw(40) << "multipoles with r translation " << byMultipolesWithRealTranslation << std::endl;
   std::cout << std::setw(40) << "multipoles with layers CPU" << byMultipolesWithLayersCPU << std::endl;
   std::cout << std::setw(40) << "multipoles with layers GPU" << byMultipolesWithLayersGPU << std::endl;
   std::cout << std::setw(40) << "multipoles with matrices CPU" << byMultipolesWithMatricesCPU << std::endl;
   std::cout << std::setw(40) << "multipoles with matrices GPU" << byMultipolesWithMatricesGPU << std::endl;
}

void octreeFormingTime()
{
   constexpr double torusRadius = 2;
   constexpr double torusSectionWidth = 0.2;

   size_t w = 15;

   for(size_t i = 1; i < 16; i++)
   {
      Torus torus(torusRadius, torusSectionWidth, 10 * i, 16, 16);
      auto bq = readTetrahedronBasisQuadratures();
      auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);

      auto start = std::chrono::steady_clock::now();
      MultipoleSolver multipoleSolver(quadratures, Problem::BioSavartLaplace, 1000);
      auto stop = std::chrono::steady_clock::now();
      double timeForOctreeForming = getTime(start, stop);

      std::cout << quadratures.size() << " ";
      std::cout << timeForOctreeForming << std::endl;
   }
}

void calculationTimeForMultipolesInLeaves()
{
   constexpr double torusRadius = 2;
   constexpr double torusSectionWidth = 0.2;

   size_t w = 15;

   for(size_t i = 1; i < 15; i++)
   {
      Torus torus(torusRadius, torusSectionWidth, 10 * i, 16, 16);
      auto bq = readTetrahedronBasisQuadratures();
      auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);

      MultipoleSolver multipoleSolver(quadratures, Problem::BioSavartLaplace, 16);

      auto start = std::chrono::steady_clock::now();
      multipoleSolver.calcMultipoleExpansionsAtLeaves();
      auto stop = std::chrono::steady_clock::now();
      double timeForMultipolesInLeaves = getTime(start, stop);

      std::cout << multipoleSolver.getQuadratureOctreeNodeCount() << " ";
      std::cout << timeForMultipolesInLeaves << std::endl;
   }
}

void calculationTimeForLocalMultipolesByLeafCapacity()
{
   auto torus = createTorus();
   auto bq = readTetrahedronBasisQuadratures();
   auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);

   size_t w = 15;

   std::cout << std::setw(w) << "leaf capacity";
   std::cout << std::setw(w) << "w/t";
   std::cout << std::setw(w) << "Complex";
   std::cout << std::setw(w) << "real";
   std::cout << std::setw(w) << "layersCPU";
   std::cout << std::setw(w) << "layersGPU";
   std::cout << std::setw(w) << "matricesCPU";
   std::cout << std::setw(w) << "matricesGPU";
   //std::cout << std::setw(w) << "matricesAda";
   std::cout << std::endl;

   std::cout << std::fixed;

   for(size_t i = 3; i < 15; i++)
   {
      int octreeLeafCapacity = pow(2, i);
      MultipoleSolver multipoleSolver(quadratures, Problem::BioSavartLaplace, octreeLeafCapacity);
      multipoleSolver.calcMultipoleExpansionsAtLeaves();
      multipoleSolver.log = false;

      auto start = std::chrono::steady_clock::now();
      multipoleSolver.calclMultipoleExpansions(M2MAlg::NoTranslation);
      auto stop = std::chrono::steady_clock::now();
      double timeWithoutTranslation = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      multipoleSolver.calclMultipoleExpansions(M2MAlg::ComplexTranslation);
      stop = std::chrono::steady_clock::now();
      double timeWithComplexTranslation = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      multipoleSolver.calclMultipoleExpansions(M2MAlg::RealTranslation);
      stop = std::chrono::steady_clock::now();
      double timeWithRealTranslation = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      multipoleSolver.calclMultipoleExpansions(M2MAlg::Layers, Device::CPU);
      stop = std::chrono::steady_clock::now();
      double timeWithLayersCPU = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      multipoleSolver.calclMultipoleExpansions(M2MAlg::Layers, Device::GPU);
      stop = std::chrono::steady_clock::now();
      double timeWithLayersGPU = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      multipoleSolver.calclMultipoleExpansions(M2MAlg::Matrices, Device::CPU);
      stop = std::chrono::steady_clock::now();
      double timeWithMatricesCPU = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      multipoleSolver.calclMultipoleExpansions(M2MAlg::Matrices, Device::GPU);
      stop = std::chrono::steady_clock::now();
      double timeWithMatricesGPU = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      //multipoleSolverWithMatricesAda.calclMultipoleExpansions(M2MAlg::Matrices, Device::Adaptive);
      stop = std::chrono::steady_clock::now();
      double timeWithMatricesAda = getTime(start, stop);

      std::cout << " " << octreeLeafCapacity;
      std::cout << " " << timeWithoutTranslation;
      std::cout << " " << timeWithComplexTranslation;
      std::cout << " " << timeWithRealTranslation;
      std::cout << " " << timeWithLayersCPU;
      std::cout << " " << timeWithLayersGPU;
      std::cout << " " << timeWithMatricesCPU;
      std::cout << " " << timeWithMatricesGPU << std::endl;
      //std::cout << " " << timeWithMatricesAda << std::endl;
   }
}


void calculationTimeForLocalMultipolesByNodeCount()
{
   constexpr double torusRadius = 2;
   constexpr double torusSectionWidth = 0.2;

   size_t w = 15;

   std::cout << std::setw(w) << "leaf capacity";
   std::cout << std::setw(w) << "w/t";
   std::cout << std::setw(w) << "Complex";
   std::cout << std::setw(w) << "real";
   std::cout << std::setw(w) << "layersCPU";
   std::cout << std::setw(w) << "layersGPU";
   std::cout << std::setw(w) << "matricesCPU";
   std::cout << std::setw(w) << "matricesGPU";
   std::cout << std::endl;

   std::cout << std::fixed;

   for(size_t i = 1; i < 8; i++)
   {
      Torus torus(torusRadius, torusSectionWidth, 40 * i, 16, 16);
      //Torus torus(torusRadius, torusSectionWidth, 40 * pow(2, i), 16, 16);
      auto bq = readTetrahedronBasisQuadratures();
      auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);

      /*MultipoleSolver multipoleSolverLCPU(quadratures, Problem::BioSavartLaplace, 8);
      multipoleSolverLCPU.calcMultipoleExpansionsAtLeaves();

      MultipoleSolver multipoleSolverLGPU(quadratures, Problem::BioSavartLaplace, 8);
      multipoleSolverLGPU.calcMultipoleExpansionsAtLeaves();*/

      MultipoleSolver multipoleSolverMCPU(quadratures, Problem::BioSavartLaplace, 8);
      multipoleSolverMCPU.calcMultipoleExpansionsAtLeaves();
      //multipoleSolverMCPU.log = true;

      //MultipoleSolver multipoleSolverMGPU(quadratures, Problem::BioSavartLaplace, 8);
      //multipoleSolverMGPU.calcMultipoleExpansionsAtLeaves();
      //multipoleSolverMGPU.log = true;

      auto start = std::chrono::steady_clock::now();
      //multipoleSolver.calclMultipoleExpansions(M2MAlg::NoTranslation);
      auto stop = std::chrono::steady_clock::now();
      double timeWithoutTranslation = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      //multipoleSolver.calclMultipoleExpansions(M2MAlg::ComplexTranslation);
      stop = std::chrono::steady_clock::now();
      double timeWithComplexTranslation = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      //multipoleSolver.calclMultipoleExpansions(M2MAlg::RealTranslation);
      stop = std::chrono::steady_clock::now();
      double timeWithRealTranslation = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      //multipoleSolverLCPU.calclMultipoleExpansions(M2MAlg::Layers, Device::CPU);
      stop = std::chrono::steady_clock::now();
      double timeWithLayersCPU = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      //multipoleSolverLGPU.calclMultipoleExpansions(M2MAlg::Layers, Device::GPU);
      stop = std::chrono::steady_clock::now();
      double timeWithLayersGPU = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      multipoleSolverMCPU.calclMultipoleExpansions(M2MAlg::Matrices, Device::GPU);
      stop = std::chrono::steady_clock::now();
      double timeWithMatricesCPU = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      //multipoleSolverMGPU.calclMultipoleExpansions(M2MAlg::Matrices, Device::GPU);
      stop = std::chrono::steady_clock::now();
      double timeWithMatricesGPU = getTime(start, stop);

      std::cout << std::scientific;
      //std::cout << " " << (real)multipoleSolverMCPU.getQuadratureOctreeNodeCount();
      //std::cout << " " << timeWithoutTranslation;
      //std::cout << " " << timeWithComplexTranslation;
      //std::cout << " " << timeWithRealTranslation;
      //std::cout << " " << timeWithLayersCPU;
      //std::cout << " " << timeWithLayersGPU;
      std::cout << " " << timeWithMatricesCPU << std::endl;
      //std::cout << " " << timeWithMatricesGPU << std::endl;
   }
}

std::pair<double, Vector3> wholeTimeForIntegrals(const std::vector<Vector3>& points, 
                           std::vector<Quadrature>& quadratures)
{
   Vector3 res;
   auto start = std::chrono::steady_clock::now();

   for(size_t p = 0; p < points.size(); p++)
   {
      res += math::calcBioSavartLaplace(current, points[p], quadratures);
   }

   auto stop = std::chrono::steady_clock::now();
   
   return std::pair<double, Vector3>
      (std::chrono::duration_cast<std::chrono::nanoseconds>(stop - start).count() * 1e-9, res);
}

std::pair<double, Vector3>  timeForMultipoles(
   const std::vector<Vector3>& points,
   std::vector<Quadrature>& quadratures,
   M2MAlg alg, 
   Device device)
{
   Vector3 res;
   auto start = std::chrono::steady_clock::now();
   MultipoleSolver multipoleSolver(quadratures);
   multipoleSolver.calclMultipoleExpansions(alg, device);

   for(size_t p = 0; p < points.size(); p++)
   {
      res += multipoleSolver.calcB(current, points[p]);
   }

   auto stop = std::chrono::steady_clock::now();

   return { getTime(start, stop), res };
}

void NMResearch1()
{
   const double torusRadius = 2;
   const double torusSectionWidth = 0.2;
   Vector3 begin(3, 1, 2);
   Vector3 end(0, 0, 0);
   BasisQuadratures bq = readTetrahedronBasisQuadratures();

   std::cout << std::setw(16) << "NM";
   std::cout << std::setw(16) << "w/t";
   std::cout << std::setw(16) << "matrices";
   std::cout << std::endl;

   double prevTimeIntegrals = 0;
   double prevTimeMatrices = 0;

   for(size_t i = 1; i < 15; i++)
   {
      Torus torus(torusRadius, torusSectionWidth, pow(2, i), 4, 4);
      auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);

      int pointsCount = 3840 * pow(2, i - 1);
      auto points = createPoints(begin, end, pointsCount);

      std::cout << std::fixed;
      std::cout << std::setw(16) << pointsCount * quadratures.size() << " ";
      std::cout << std::scientific;

      if(i < 5)
         prevTimeIntegrals = wholeTimeForIntegrals(points, quadratures).first;
      else
         prevTimeIntegrals *= 4;

      if(i < 8)
         prevTimeMatrices = timeForMultipoles(points, quadratures, M2MAlg::Matrices, Device::GPU).first;
      else
         prevTimeMatrices = 0;

      std::cout << std::setw(16) << prevTimeIntegrals;
      std::cout << std::setw(16) << prevTimeMatrices << std::endl;
   }
}

void NMResearch2()
{
   const double torusRadius = 2;
   const double torusSectionWidth = 0.2;
   BasisQuadratures bq = readTetrahedronBasisQuadratures();

   std::cout << std::setw(16) << "NM";
   std::cout << std::setw(16) << "w/t";
   std::cout << std::setw(16) << "matrices";
   std::cout << std::setw(16) << "Fmm";
   std::cout << std::endl;

   double prevTimeIntegrals = 0;
   double prevTimeMatrices = 0;

   for(size_t i = 1; i < 15; i++)
   {
      Torus torus(torusRadius, torusSectionWidth, pow(2, i), 4, 4);
      auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);

      int pointCount = 3840 * pow(2, i - 1);
      auto points = createRandomPoints(Box({ 0, 0, 0 }, { 2, 2, 2 }), pointCount);

      std::cout << std::fixed;
      std::cout << std::setw(16) << pointCount * quadratures.size() << " ";
      std::cout << std::scientific;

      /*if(i < 5)
         prevTimeIntegrals = wholeTimeForIntegrals(points, quadratures).first;
      else
         prevTimeIntegrals *= 4;*/
      

      /*if(i < 15)
         prevTimeMatrices = timeForMultipoles(points, quadratures, M2MAlg::ComplexTranslation, Device::GPU).first;
      else
         prevTimeMatrices *= 2;*/

      std::cout << std::setw(16) << prevTimeIntegrals;
      std::cout << std::setw(16) << prevTimeMatrices;

      auto start = std::chrono::steady_clock::now();
      FastMultipoleSolver fmmSolver(quadratures, points, Problem::BioSavartLaplace, 1000, 100);
      fmmSolver.calcMultipoleExpansionsAtLeaves();
      fmmSolver.calclMultipoleExpansions(M2MAlg::Matrices, Device::CPU);
      fmmSolver.calcLocalMultipoleExpansions(M2LAlg::ComplexTranslation, Device::CPU);
      auto fmmResults = fmmSolver.calcB(current);
      auto stop = std::chrono::steady_clock::now();
      auto time = getTime(start, stop);

      std::cout << std::setw(16) << time << std::endl;
   }
}

void layerCalculationsPrecision()
{
   Torus torus = createTorus();
   BasisQuadratures bq = readTetrahedronBasisQuadratures();
   auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);
   MultipoleSolver multipoleSolverCPU(quadratures);
   MultipoleSolver multipoleSolverGPU(quadratures);

   Vector3 point(3, 1, 2);

   Vector3 byIntegration = math::calcBioSavartLaplace(current, point, quadratures);

   multipoleSolverCPU.calclMultipoleExpansions(M2MAlg::Layers, Device::CPU);
   Vector3 byMultipolesWithLayersCPU = multipoleSolverCPU.calcB(current, point);

   multipoleSolverGPU.calclMultipoleExpansions(M2MAlg::Layers, Device::GPU);
   Vector3 byMultipolesWithLayersGPU = multipoleSolverGPU.calcB(current, point);

   std::cout << std::setw(20) << "point ";
   point.printWithWidth(std::cout, 6);
   std::cout << std::scientific << std::endl;
   std::cout << std::setw(40) << "integration " << byIntegration << std::endl;
   std::cout << std::setw(40) << "multipoles with layers CPU" << byMultipolesWithLayersCPU << std::endl;
   std::cout << std::setw(40) << "multipoles with layers GPU" << byMultipolesWithLayersGPU << std::endl;
}

void layerCalculationTime()
{
   Torus torus = createTorus();
   BasisQuadratures bq = readTetrahedronBasisQuadratures();
   auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);

   Vector3 point(3, 1, 2);

   size_t w = 15;

   for(size_t i = 1; i < 2; i++)
   {
      int octreeLeafCapacity = pow(2, i);
      MultipoleSolver multipoleSolverCPU(quadratures, Problem::BioSavartLaplace, octreeLeafCapacity);
      MultipoleSolver multipoleSolverGPU(quadratures, Problem::BioSavartLaplace, octreeLeafCapacity);

      std::cout << std::setw(w) << "leaf capacity:";
      std::cout << std::setw(w) << octreeLeafCapacity << std::endl;

      auto start = std::chrono::steady_clock::now();
      multipoleSolverCPU.calclMultipoleExpansions(M2MAlg::Layers, Device::CPU);
      auto stop = std::chrono::steady_clock::now();
      double timeWithCPU = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      multipoleSolverGPU.calclMultipoleExpansions(M2MAlg::Layers, Device::GPU);
      stop = std::chrono::steady_clock::now();
      double timeWithGPU = getTime(start, stop);

      std::cout << std::setw(w) << "total time CPU:";
      std::cout << std::setw(w) << timeWithCPU << std::endl;
      std::cout << std::setw(w) << "total time GPU:";
      std::cout << std::setw(w) << timeWithGPU << std::endl;
   }
}

void matrixCalculationTime()
{
   Torus torus = createTorus();
   BasisQuadratures bq = readTetrahedronBasisQuadratures();
   auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);

   Vector3 point(3, 1, 2);

   size_t w = 15;

   for(size_t i = 1; i < 2; i++)
   {
      int octreeLeafCapacity = pow(2, i);
      MultipoleSolver multipoleSolverCPU(quadratures, Problem::BioSavartLaplace, octreeLeafCapacity);
      //MultipoleSolver multipoleSolverGPU(quadratures, quadratureOctreeLeafCapacity);
      //MultipoleSolver multipoleSolverAda(quadratures, quadratureOctreeLeafCapacity);

      std::cout << std::setw(w) << "leaf capacity:";
      std::cout << std::setw(w) << octreeLeafCapacity << std::endl;

      auto start = std::chrono::steady_clock::now();
      multipoleSolverCPU.calclMultipoleExpansions(M2MAlg::Matrices, Device::CPU);
      auto stop = std::chrono::steady_clock::now();
      double timeWithCPU = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      //multipoleSolverGPU.calclMultipoleExpansions(M2MAlg::Matrices, Device::GPU);
      stop = std::chrono::steady_clock::now();
      double timeWithGPU = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      //multipoleSolverAda.calclMultipoleExpansions(M2MAlg::Matrices, Device::Adaptive);
      stop = std::chrono::steady_clock::now();
      double timeWithAda = getTime(start, stop);

      std::cout << std::setw(w) << "total time CPU:";
      std::cout << std::setw(w) << timeWithCPU << std::endl;
      std::cout << std::setw(w) << "total time GPU:";
      std::cout << std::setw(w) << timeWithGPU << std::endl;
      std::cout << std::setw(w) << "total time Ada:";
      std::cout << std::setw(w) << timeWithAda << std::endl;
   }
}

void layerMatrixCalculationTime(Device device)
{
   Torus torus = createTorus();
   BasisQuadratures bq = readTetrahedronBasisQuadratures();
   auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);

   Vector3 point(3, 1, 2);

   size_t w = 15;

   for(size_t i = 10; i < 10; i++)
   {
      int octreeLeafCapacity = pow(2, i);
      MultipoleSolver multipoleSolverLayers(quadratures, Problem::BioSavartLaplace, octreeLeafCapacity);
      MultipoleSolver multipoleSolverMatrices(quadratures, Problem::BioSavartLaplace, octreeLeafCapacity);

      std::cout << std::setw(w) << "leaf capacity:";
      std::cout << std::setw(w) << octreeLeafCapacity << std::endl;

      auto start = std::chrono::steady_clock::now();
      multipoleSolverLayers.calclMultipoleExpansions(M2MAlg::Layers, device);
      auto stop = std::chrono::steady_clock::now();
      double timeWithLayers = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      multipoleSolverMatrices.calclMultipoleExpansions(M2MAlg::Matrices, device);
      stop = std::chrono::steady_clock::now();
      double timeWithMatrices = getTime(start, stop);

      
      std::cout << "device" << std::setw(w) << (device == Device::GPU ? "GPU" : "CPU") << std::endl;
      std::cout << "layers:  " << std::setw(w) << timeWithLayers << std::endl;
      std::cout << "matrices:" << std::setw(w) << timeWithMatrices << std::endl;
   }
}

void cudaAddingTest()
{
   std::vector<real> a = { 1, 2, 3, 4 };
   std::vector<real> b = { 10, 20, 30, 100 };
   std::cout << kernels::addVectors(a, b);
}

void printIndeces()
{
   int n = 10;
   int N = (n + 1) * (n + 1);
   std::vector<std::vector<bool>> matrix(N, std::vector<bool>(N));
   std::ofstream foutIdx("results/indeces.txt");
   std::ofstream foutMatrix("results/regular_matrix.txt");
   int w = 1;

   for(int l = 0; l <= n; l++)
   {
      for(int m = -l; m <= l; m++)
      {
         std::stringstream line;

         line << "M(" << std::setw(w) << l << "," << std::setw(w) << m << ") = ";

         for(int lambda = 0; lambda <= l; lambda++)
         {
            int dl = l - lambda;
            line << "[";

            for(int mu = -lambda; mu <= lambda; mu++)
            {
               int dm = m - mu;

               if(-dl <= dm && dm <= dl)
               {
                  line << "R(" << std::setw(w) << lambda << "," << std::setw(w) << mu << ")";
                  line << "M(" << std::setw(w) << dl << "," << std::setw(w) << dm << ")";
                  
                  if(mu != lambda && lambda != l)
                     line << " + ";
                  else
                     line << "] + ";

                  matrix[l * l + l + m][dl * dl + dl + dm] = true;
               }
            }
         }

         line << std::endl;
         std::string newStr = line.str();
         newStr.erase(newStr.end() - 3);
         line.str(newStr);
         foutIdx << line.str();
      }

      foutIdx << "------------------------------------" << std::endl;
   }

   //for(int l = 0; l <= _order; l++)
   //{
   //   for(int m = -l; m <= l; m++)
   //   {
   //      for(int lambda = 0; lambda <= l; lambda++)
   //      {
   //         for(int mu = -lambda; mu <= lambda; mu++)
   //         {
   //            foutMatrix << (matrix[l * l + l + m][lambda * lambda + lambda + mu] 
   //                           ? "O" : ".") << " ";
   //         }
   //      }
   //      foutMatrix << std::endl;
   //   }
   //}

   std::vector<int> indx;
   int id = 1;

   while(id < N)
   {
      indx.push_back((id * id) - 1);
      id++;
   }
   

   for(int i = 0; i < N; i++)
   {
      for(int j = 0; j < N; j++)
      {
         if(j <= i)
         {
            foutMatrix << (matrix[i][j] ? "O" : ".");

            for(size_t k = 0; k < indx.size(); k++)
            {
               if(indx[k] == j)
               {
                  foutMatrix << "|";
                  break;
               }
            }
         }
      }

      foutMatrix << std::endl;

      for(size_t k = 0; k < indx.size(); k++)
      {
         if(indx[k] == i)
         {
            for(size_t o = 0; o < N + n + 1; o++)
            {
               foutMatrix << "-";
            }

            foutMatrix << std::endl;
            break;
         }
      }
   }

}

void matrixCalculationsPrecision()
{
   Torus torus = createTorus();
   BasisQuadratures bq = readTetrahedronBasisQuadratures();
   auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);
   MultipoleSolver multipoleSolver(quadratures);
   multipoleSolver.calcMultipoleExpansionsAtLeaves();
   //MultipoleSolver multipoleSolverAda(quadratures);

   Vector3 point(3, 1, 2);

   Vector3 byIntegration = math::calcBioSavartLaplace(current, point, quadratures);

   multipoleSolver.calclMultipoleExpansions(M2MAlg::Matrices, Device::CPU);
   Vector3 byMultipolesWithLayersCPU = multipoleSolver.calcB(current, point);

   multipoleSolver.calclMultipoleExpansions(M2MAlg::Matrices, Device::GPU);
   Vector3 byMultipolesWithLayersGPU = multipoleSolver.calcB(current, point);

   //multipoleSolverAda.calclMultipoleExpansions(M2MAlg::Matrices, Device::Adaptive);
   //Vector3 byMultipolesWithLayersAda = multipoleSolverAda.calcB(current, point);

   std::cout << std::setw(20) << "point ";
   point.printWithWidth(std::cout, 6);
   std::cout << std::scientific << std::endl;
   std::cout << std::setw(40) << "integration " << byIntegration << std::endl;
   std::cout << std::setw(40) << "multipoles with matrices CPU" << byMultipolesWithLayersCPU << std::endl;
   std::cout << std::setw(40) << "multipoles with matrices GPU" << byMultipolesWithLayersGPU << std::endl;
   //std::cout << std::setw(40) << "multipoles with matrices Ada" << byMultipolesWithLayersAda << std::endl;
}

void translationTest()
{
   /*Vector3 a(3, 2, 1);
   Vector3 b(1, 7, 4);
   
   auto seriesA = Harmonics(10, a).sphericalHarmonics();
   auto complexSeriesA1 = Harmonics::realToComplex(seriesA);
   auto realSeriesA1 = Harmonics::complexToReal(complexSeriesA1);
   
   std::vector<Complex> temp1(121);
   cblas_scopy(121, seriesA.data().data(), 1, (float*)temp1.data(), 2);
   auto realToComplexMatrix2D = Harmonics::calcRealToComplexMatrix2D(10);
   auto complexSeriesA2 = math::mult(temp1, realToComplexMatrix2D);
   auto complexToRealMatrix2D = Harmonics::calcComplexToRealMatrix2D(10);
   auto temp2 = math::mult(complexSeriesA2, complexToRealMatrix2D);
   std::vector<real> realSeriesA2(121);
   cblas_scopy(121, (float*)temp2.data(), 2, realSeriesA2.data(), 1);

   auto realToComplexMatrixTransposed1D =
      Harmonics::calcRealToComplexTransitionMatrix1D(10);
   auto complexToRealMatrixTransposed1D =
      Harmonics::calcComplexToRealTransitionMatrix1D(10);

   auto matricesMultiplied = math::multMatricesAsVectors(
      complexToRealMatrixTransposed1D,
      realToComplexMatrixTransposed1D,
      121, 121, 121
   );

   auto deb = math::multMatricesAsVectors(
      temp1,
      matricesMultiplied,
      121, 1, 121);*/

   Vector3 a(3, 2, 1);
   Vector3 b(1, 7, 4);

   Vector3 translation = a - b;

   auto seriesA = Harmonics(10, a).sphericalHarmonics();
   auto reg = Harmonics::calcRegularSolidHarmonics(10, translation);
   
   auto seriesA1Translated = MultipoleTranslator::translateMultipole(
      seriesA, reg);

   std::vector<Complex> temp1(121);
   blas::copyVector(121, seriesA.data().data(), 1, (real*)temp1.data(), 2);
   auto realToComplexMatrix2D = Harmonics::calcRealToComplexMatrix2D(10);
   auto complexSeriesA2 = math::mult(temp1, realToComplexMatrix2D);
   auto complexToRealMatrix2D = Harmonics::calcComplexToRealMatrix2D(10);
   auto temp2 = math::mult(complexSeriesA2, complexToRealMatrix2D);
   std::vector<real> realSeriesA2(121);
   blas::copyVector(121, (real*)temp2.data(), 2, realSeriesA2.data(), 1);

   auto realToComplexMatrixTransposed1D =
      Harmonics::calcRealToComplexTransitionMatrix1D(10);
   auto complexToRealMatrixTransposed1D =
      Harmonics::calcComplexToRealTransitionMatrix1D(10);

   auto matricesMultiplied = math::multMatricesAsVectors(
      complexToRealMatrixTransposed1D,
      realToComplexMatrixTransposed1D,
      121, 121, 121
   );

   auto deb = math::multMatricesAsVectors(
      temp1,
      matricesMultiplied,
      121, 1, 121);
}

void multipoleToLocalTest()
{
   int n = 10;
   Vector3 point1(3, 1, 2);
   Vector3 point2(4, 5, 1);

   auto r1 = Harmonics::calcRegularSolidHarmonics(n, point1);
   auto c1 = Harmonics::realToComplex(r1);

   auto r2 = Harmonics::calcRegularSolidHarmonics(n, point2);
   auto c2 = Harmonics::realToComplex(r2);

   auto t = Harmonics::complexToReal(
      MultipoleTranslator::translateLocal(c1, c2));
}

void FMMPrecisionTest()
{
   Torus torus = createTorus();
   BasisQuadratures bq = readTetrahedronBasisQuadratures();
   auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);
   //Vector3 begin(10, 10, 10);
   //Vector3 end(9, 9, 9);
   Vector3 begin(4, 4, 4);
   Vector3 end(1, 1, 1);
   //auto points = createPoints(begin, end, 10);
   //std::vector<Vector3> points = {{2, 2, 0}};
   //std::vector<Vector3> points = {{3, 3, 3}};
   //auto points = createRandomPoints(Box({ 0, 0, 0 }, { 2, 2, 2 }), 256);
   auto points = createRandomPoints(Box({ 10, 10, 10 }, { 2, 2, 2 }), 256);
   //auto points = std::vector<Vector3>({ Vector3(10.5, 5, 8) });

   FastMultipoleSolver multipoleSolver(quadratures, points, Problem::BioSavartLaplace, 64, 32);
   multipoleSolver.log = false;
   multipoleSolver.calcMultipoleExpansionsAtLeaves();
   multipoleSolver.calclMultipoleExpansions(M2MAlg::Matrices, Device::GPU);
   //multipoleSolver.calcLocalMultipoleExpansions(M2LAlg::ComplexTranslation, Device::CPU);
   multipoleSolver.calcLocalMultipoleExpansions(M2LAlg::Matrices, Device::CPU);

   auto fmmResults = multipoleSolver.calcB(current);
   
   real averageAbsoluteError = 0;
   real averageRelativeError = 0;

   for(size_t i = 0; i < points.size(); ++i)
   {
      auto point = fmmResults[i].first;
      auto aInPointByFmm = fmmResults[i].second;
      auto byMultipolesWithMatricesGPU = multipoleSolver.calcB(current, point);

      real absoluteError = (aInPointByFmm - byMultipolesWithMatricesGPU).length();
      real relativeError = 100 * absoluteError / byMultipolesWithMatricesGPU.length();

      averageAbsoluteError += absoluteError;
      averageRelativeError += relativeError;

      test::printSeparateLine(std::cout, 100);
      std::cout << std::scientific;
      std::cout << std::setw(40) << "point: " << point << "\n";
      std::cout << std::setw(40) << "multipoles with matrices GPU: " << byMultipolesWithMatricesGPU << "\n";
      std::cout << std::setw(40) << "fmm: " << aInPointByFmm << " ";
      std::cout << std::setw(10) << relativeError << "\n";
   }

   std::cout << "averageAbsoluteError: " << averageAbsoluteError / points.size() << "\n";
   std::cout << "averageRelativeError: " << averageRelativeError / points.size() << "\n";
}

void FMMTimeTest()
{
   Torus torus = createTorus();
   BasisQuadratures bq = readTetrahedronBasisQuadratures();
   auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);

   std::cout << std::setw(9) << "points";
   std::cout << std::setw(16) << "errorComplex";
   //std::cout << std::setw(16) << "errorMatrices";
   std::cout << std::setw(16) << "noFMMTime";
   std::cout << std::setw(16) << "timeComplex" << "\n";
   //std::cout << std::setw(16) << "timeMatrices" << "\n";
   test::printSeparateLine(std::cout, 100);

   for(size_t i = 0; i < 33; i++)
   {
      size_t pointCount = pow(2, i);
      //size_t pointCount = (i + 1) * quadratures.size();
      //auto points = createRandomPoints(Box({ 0, 0, 0 }, { 2, 2, 2 }), pointCount);
      auto points = createRandomPoints(Box({ 0, 0, 0 }, { 2, 2, 2 }), pointCount);
      FastMultipoleSolver multipoleSolverComplex(quadratures, points, Problem::BioSavartLaplace, 128, 32);
      //FastMultipoleSolver multipoleSolverMatricesGPU(quadratures, points, 128, 32);
      multipoleSolverComplex.log = false;
      //multipoleSolverMatricesGPU.log = false;
      
      multipoleSolverComplex.calcMultipoleExpansionsAtLeaves();
      multipoleSolverComplex.calclMultipoleExpansions(M2MAlg::Matrices, Device::GPU);

      auto start = std::chrono::steady_clock::now();
      multipoleSolverComplex.calcLocalMultipoleExpansions(M2LAlg::ComplexTranslation, Device::GPU);
      auto stop = std::chrono::steady_clock::now();
      double fmmPartTimeComplex = test::getTime(start, stop);
      
      //multipoleSolverMatricesGPU.calcMultipoleExpansionsAtLeaves();
      //multipoleSolverMatricesGPU.calclMultipoleExpansions(M2MAlg::Matrices, Device::GPU);

      //start = std::chrono::steady_clock::now();
      //multipoleSolverMatricesGPU.calcLocalMultipoleExpansions(M2LAlg::Matrices, Device::GPU);
      //stop = std::chrono::steady_clock::now();
      //double fmmPartTimeMatrices = test::getTime(start, stop);

      Vector3 noFMMResComplex;
      Vector3 FMMResComplex;
      //Vector3 FMMResMatrices;

      start = std::chrono::steady_clock::now();
      for(auto& point : points)
      {
         noFMMResComplex += multipoleSolverComplex.calcB(current, point);
      }
      stop = std::chrono::steady_clock::now();
      double noFMMTime = test::getTime(start, stop);

      start = std::chrono::steady_clock::now();
      auto fmmComplexResults = multipoleSolverComplex.calcB(current);
      stop = std::chrono::steady_clock::now();
      double FMMTime = test::getTime(start, stop);

      //start = std::chrono::steady_clock::now();
      //auto fmmMatricesResults = multipoleSolverMatricesGPU.calcB(current);
      //stop = std::chrono::steady_clock::now();
      //double FMMTimeMatrices = test::getTime(start, stop);

      for (auto &[point, fmmResult] : fmmComplexResults)
      {
         FMMResComplex += fmmResult;
      }

      //for(auto& [point, fmmResult] : fmmMatricesResults)
      //{
      //   FMMResMatrices += fmmResult;
      //}

      std::cout << std::fixed << std::setw(9) << pointCount;
      std::cout << std::scientific;
      std::cout << std::setw(16) << 100 * (noFMMResComplex - FMMResComplex).length() / noFMMResComplex.length();
      //std::cout << std::setw(16) << 100 * (noFMMResComplex - FMMResMatrices).length() / noFMMResComplex.length();
      std::cout << std::setw(16) << noFMMTime;
      std::cout << std::setw(16) << FMMTime + fmmPartTimeComplex << "\n";
      //std::cout << std::setw(16) << FMMTimeMatrices + fmmPartTimeMatrices << "\n";
   }
}

void translationTest2()
{
   Vector3 a(4.2, 6.9, 2.1);
   Vector3 b(4, 7, 2);
   size_t order = 10;
   size_t harmonicLength = 121;
   size_t matrixElemCount = harmonicLength * harmonicLength;

   //auto trans = a - b;
   auto trans = a - b;
   auto harm = Harmonics::calcRegularSolidHarmonics(order, b);
   auto harmAComplex = Harmonics::realToComplex(harm);
   auto regular = Harmonics::realToComplex(Harmonics::calcRegularSolidHarmonics(order, trans));
   //auto realRegular = Harmonics::calcRegularSolidHarmonics(order, trans);
   //auto trueResult = MultipoleTranslator::translateMultipole(realRegular, harm).data();

   auto trueResult1 = Harmonics::complexToReal(
      MultipoleTranslator::translateLocal(harmAComplex, regular)).data();

   std::vector<Complex> regularMatrix(harmonicLength * harmonicLength);

   /*for(int l = 0; l <= order; l++)
   {
      for(int m = -l; m <= l; m++)
      {
         for(int lambda = 0; lambda <= l; lambda++)
         {
            int dl = l - lambda;

            for(int mu = -lambda; mu <= lambda; mu++)
            {
               int dm = m - mu;

               if(-dl <= dm && dm <= dl)
               {
                  regularMatrix[(l * l + l + m) + (dl * dl + dl + dm) * harmonicLength] =
                     regular.getHarmonic(lambda * lambda + lambda + mu) *
                     MultipoleTranslator::multipoleTranslationFactor(m, mu);
               }
            }
         }
      }
   }*/

   for(int l = 0; l <= regular.order(); l++)
   {
      for(int m = -l; m <= l; m++)
      {
         for(int lambda = 0; lambda <= l; lambda++)
         {
            int dl = lambda - l;
            if(dl >= 0)
            {
               for(int mu = -lambda; mu <= lambda; mu++)
               {
                  int dm = m - mu;

                  if(-dl <= dm && dm <= dl)
                  {
                     regularMatrix[(l * l + l + m) + (lambda * lambda + lambda + mu) * harmonicLength] =
                        regular.getHarmonic(dl * dl + dl + dm) *
                        MultipoleTranslator::localTranslationFactor(m, mu, lambda, l);
                  }
               }
            }
         }
      }
   }

   auto realToComplexMatrix = Harmonics::calcRealToComplexTransitionMatrix1D(order);
   auto complexToRealMatrix = Harmonics::calcComplexToRealTransitionMatrix1D(order);
   
   Complex alpha = makeComplex(1, 0);
   Complex beta = makeComplex(0, 0);

   std::vector<Complex> temp1(matrixElemCount);

   cblas_cgemm(
      CBLAS_ORDER::CblasRowMajor,
      CBLAS_TRANSPOSE::CblasNoTrans,
      CBLAS_TRANSPOSE::CblasNoTrans,
      harmonicLength, harmonicLength, harmonicLength,
      (float*)&alpha,
      (float*)realToComplexMatrix.data(),
      harmonicLength,
      (float*)regularMatrix.data(),
      harmonicLength,
      (float*)&beta,
      (float*)temp1.data(),
      harmonicLength);

   std::vector<Complex> temp2(matrixElemCount);
   std::vector<real> result(matrixElemCount);

   cblas_cgemm(
      CBLAS_ORDER::CblasRowMajor,
      CBLAS_TRANSPOSE::CblasNoTrans,
      CBLAS_TRANSPOSE::CblasNoTrans,
      harmonicLength, harmonicLength, harmonicLength,
      (float*)&alpha,
      (float*)temp1.data(),
      harmonicLength,
      (float*)complexToRealMatrix.data(),
      harmonicLength,
      (float*)&beta,
      (float*)temp2.data(),
      harmonicLength);

   blas::copyVector(
      matrixElemCount,
      (real*)(temp2.data()), 2,
      result.data(), 1);

   int m = harmonicLength;
   int k = harmonicLength;
   int n = 1;
   int lda = m, ldb = k, ldc = m;
   const real alpha1 = 1;
   const real beta1 = 0;
   
   std::vector<real> notTrueResult(harmonicLength);

   blas::multMatrices(CBLAS_ORDER::CblasColMajor,
               CBLAS_TRANSPOSE::CblasNoTrans,
               CBLAS_TRANSPOSE::CblasNoTrans,
               m, n, k,
               alpha1,
               result.data(), ldb, harm.data().data(), lda,
               beta1,
               notTrueResult.data(), ldc);

}

void timeForFullFMMByQuadratures()
{
   const double torusRadius = 2;
   const double torusSectionWidth = 0.2;
   Vector3 begin(3, 1, 2);
   Vector3 end(0, 0, 0);
   BasisQuadratures bq = readTetrahedronBasisQuadratures();
   int pointsCount = 1000;
   auto points = createRandomPoints({{0, 0, 0}, {2, 2, 2}}, pointsCount);

   for(size_t i = 5; i < 15; i++)
   {
      Torus torus(torusRadius, torusSectionWidth, pow(2, i + 1), 4, 4);
      auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);
      FastMultipoleSolver fmmSolver(quadratures, points, Problem::BioSavartLaplace, 1000, 100);

      auto start = std::chrono::steady_clock::now();
      fmmSolver.calcMultipoleExpansionsAtLeaves();
      fmmSolver.calclMultipoleExpansions(M2MAlg::Matrices, Device::GPU);
      auto stop = std::chrono::steady_clock::now();
      auto time1 = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      fmmSolver.calcLocalMultipoleExpansions(M2LAlg::ComplexTranslation, Device::CPU);
      stop = std::chrono::steady_clock::now();
      auto time2 = getTime(start, stop);

      std::cout << std::fixed;
      std::cout << std::setw(5) << pointsCount * quadratures.size() << " ";
      std::cout << std::scientific;
      std::cout << std::setw(8) << time1 << " " << time2 << std::endl << std::endl;
   }
}

void timeForFullFMMByPointCount()
{
   const double torusRadius = 2;
   const double torusSectionWidth = 0.2;
   Vector3 begin(3, 1, 2);
   Vector3 end(0, 0, 0);
   BasisQuadratures bq = readTetrahedronBasisQuadratures();
   Torus torus(torusRadius, torusSectionWidth, 20, 4, 4);
   auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);

   for(size_t i = 5; i < 30; i++)
   {
      int pointsCount = pow(2, i);
      auto points = createRandomPoints({ {0, 0, 0}, {2, 2, 2} }, pointsCount);
      FastMultipoleSolver fmmSolver(quadratures, points, Problem::BioSavartLaplace, 1000, 100);

      auto start = std::chrono::steady_clock::now();
      fmmSolver.calcMultipoleExpansionsAtLeaves();
      fmmSolver.calclMultipoleExpansions(M2MAlg::Matrices, Device::GPU);
      auto stop = std::chrono::steady_clock::now();
      auto time1 = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      fmmSolver.calcLocalMultipoleExpansions(M2LAlg::ComplexTranslation, Device::CPU);
      stop = std::chrono::steady_clock::now();
      auto time2 = getTime(start, stop);

      std::cout << std::fixed;
      std::cout << std::setw(5) << pointsCount * quadratures.size() << " ";
      std::cout << std::scientific;
      std::cout << std::setw(8) << time1 << " " << time2 << std::endl;
   }
}

void timeForTallCube()
{
   const double torusRadius = 2;
   const double torusSectionWidth = 0.2;
   Vector3 begin(3, 1, 2);
   Vector3 end(0, 0, 0);
   BasisQuadratures bq = readTetrahedronBasisQuadratures();
   Torus torus(torusRadius, torusSectionWidth, 20, 4, 4);
   auto quadratures = math::tetrahedraToQuadratures(torus.tetrahedra, bq);
   int pointsCount = quadratures.size();

   for(size_t i = 2; i < 40; i++)
   {
      auto points = createRandomPoints({ 
         {0, 0, 0},
         {2, 2, static_cast<real>(i)}
      }, pointsCount);

      std::cout << std::scientific;

      FastMultipoleSolver fmmSolver(quadratures, points, Problem::BioSavartLaplace, 1000, 100);

      auto start = std::chrono::steady_clock::now();
      fmmSolver.calcMultipoleExpansionsAtLeaves();
      fmmSolver.calclMultipoleExpansions(M2MAlg::Matrices, Device::CPU);
      auto stop = std::chrono::steady_clock::now();
      auto time1 = getTime(start, stop);

      start = std::chrono::steady_clock::now();
      fmmSolver.calcLocalMultipoleExpansions(M2LAlg::ComplexTranslation, Device::CPU);
      stop = std::chrono::steady_clock::now();
      auto time2 = getTime(start, stop);
         
      std::cout << std::fixed;
      std::cout << std::setw(5) << i << " ";
      std::cout << std::scientific;
      std::cout << std::setw(8) << time1 << " " << time2 << " ";

      real sumAverageError = 0;

      auto resultPoints = fmmSolver.calcB(current);

      for (auto &[point, bFmm] : resultPoints)
      {
         auto b = fmmSolver.calcB(current, point);

         sumAverageError += 100 * (bFmm - b).length() / b.length();
      }

      std::cout << std::setw(8) << sumAverageError / resultPoints.size() << std::endl;
   }
}


void BApproximationOnCylinder()
{
   auto externalCylinderSides = readCylinderData("cylinder/ВнешнийЦилиндр.0");
   auto externalCylinderTop = readCylinderData("cylinder/ВнешнийЦилиндрВерх.0");
   auto externalCylinderBottom = readCylinderData("cylinder/ВнешнийЦилиндрНиз.0");
   auto internalCylinder = readCylinderData("cylinder/Внутренний Цилиндр.0");

   Cylinder cylinder = createCylinder();
   BasisQuadratures bq = readTriangleBasisQuadratures();

   auto BEMQuadraturesSide = math::calcBEMquadraturesFromTriangles(
      cylinder.sideTriangles(), bq, externalCylinderSides, 0);

   auto BEMQuadraturesTop = math::calcBEMquadraturesFromTriangles(
      cylinder.topTriangles(), bq, externalCylinderTop, 1);

   auto BEMQuadraturesBottom = math::calcBEMquadraturesFromTriangles(
      cylinder.bottomTriangles(), bq, externalCylinderBottom, -1);

   real sumErrorFmmSolver = 0;
   real totalTime = 0;

   for(size_t i = 0; i < internalCylinder.size(); i++)
   {
      std::cout << std::setw(5) << i << " ";

      Vector3 trueRes = internalCylinder[i].B;
      Vector3 res;

      auto start = std::chrono::steady_clock::now();
      res += math::calcBEMIntegral(internalCylinder[i].point, BEMQuadraturesSide);
      res += math::calcBEMIntegral(internalCylinder[i].point, BEMQuadraturesTop);
      res += math::calcBEMIntegral(internalCylinder[i].point, BEMQuadraturesBottom);
      auto stop = std::chrono::steady_clock::now();
      totalTime += test::getTime(start, stop);

      res.printWithWidth(std::cout, 9);
      trueRes.printWithWidth(std::cout, 9);

      real relativeError = 100 * (res - trueRes).length() / trueRes.length();

      std::cout << std::setw(10) << relativeError << std::endl;

      sumErrorFmmSolver += relativeError;
   }

   std::cout << "Average error: ";
   std::cout << std::scientific << sumErrorFmmSolver / internalCylinder.size() << std::fixed << std::endl;
   std::cout << "Total time: " << totalTime;
}

void FMMAndBEM()
{
   auto internalCylinder = readCylinderData("cylinder/Внутренний Цилиндр.0");
   auto quadratures = test::quadraturesFromCylinder();
   std::vector<Vector3> initialPoints(internalCylinder.size());

   for(size_t i = 0; i < internalCylinder.size(); i++)
   {
      initialPoints[i] = internalCylinder[i].point;
   }

   std::cout << "FMM SOLVER BEGIN SOLVING" << std::endl;

   auto start = std::chrono::steady_clock::now();
   FastMultipoleSolver fmmSolver(quadratures, initialPoints, Problem::BEM, 256, 128);
   fmmSolver.calclMultipoleExpansions(M2MAlg::Matrices, Device::CPU);
   fmmSolver.calcLocalMultipoleExpansions(M2LAlg::ComplexTranslation, Device::GPU);
   auto results = fmmSolver.calcBEM(current);
   auto stop = std::chrono::steady_clock::now();

   real sumErrorFmmSolver = 0;

   size_t n = internalCylinder.size();

   for(size_t i = 0; i < n; i++)
   {
      auto point = results[i].first;
      Vector3 trueRes;

      for(size_t j = 0; j < n; j++)
      {
         if(point.x == internalCylinder[j].point.x &&
            point.y == internalCylinder[j].point.y &&
            point.z == internalCylinder[j].point.z)
         {
            trueRes = internalCylinder[j].B;
            break;
         }
      }
      real errorFmm = 100 * (results[i].second - trueRes).length() / trueRes.length();

      std::cout << std::fixed << std::setw(4) << i << " ";
      
      point.printWithWidth(std::cout, 9);
      results[i].second.printWithWidth(std::cout, 9);
      
      internalCylinder[i].B.printWithWidth(std::cout, 9);

      std::cout << std::scientific << std::setw(16) << errorFmm << std::fixed;
      std::cout << std::endl;

      sumErrorFmmSolver += errorFmm;
   }

   std::cout << "Average error: ";
   std::cout << std::scientific << sumErrorFmmSolver / n << std::fixed << std::endl;
   std::cout << "Total time: " << test::getTime(start, stop);
}

void stridedMatricesTest()
{
   size_t width = 10000;
   size_t height = 20000;

   std::vector<real> a(width * height);
   std::vector<real> b(width * height);

   for(size_t i = 0; i < height; i++)
   {
      for(size_t j = 0; j < width; j++)
      {
         size_t ida = i * width + j;
         size_t idb = i + j * height;
         a[ida] = j;
         b[idb] = i;
      }
   }
   
   std::vector<real> c2(width * height);

   size_t harmonicLength = width;
   size_t harmonicCount = height;

   cuda::DevPtr<real> aDev(a.data(), harmonicCount * harmonicLength);
   cuda::DevPtr<real> bDev(b.data(), harmonicLength * harmonicLength);
   cuda::DevPtr<real> cDev(harmonicCount * harmonicLength);

   int m = harmonicLength;
   int k = harmonicLength;
   int n = harmonicCount;
   int lda = m, ldb = k, ldc = m;
   const real alpha = 1;
   const real beta = 0;

   cublasHandle_t handle;
   cublasCreate(&handle);

   auto start = std::chrono::steady_clock::now();
   blas::multMatricesCUBLAS(handle, CUBLAS_OP_N, CUBLAS_OP_N, m, n, k, &alpha,
                  bDev.data(), ldb, aDev.data(), lda, &beta, cDev.data(), ldc);
   cDev.copyToHost(c2.data());
   cublasDestroy(handle);
   auto stop = std::chrono::steady_clock::now();
   std::cout << test::getTime(start, stop) << std::endl;

   std::vector<real> c3(width * height);
   start = std::chrono::steady_clock::now();
   blas::multMatrices(CBLAS_ORDER::CblasColMajor,
               CBLAS_TRANSPOSE::CblasNoTrans,
               CBLAS_TRANSPOSE::CblasNoTrans,
               m, n, k,
               alpha,
               b.data(), ldb, a.data(), lda,
               beta,
               c3.data(), ldc);
   stop = std::chrono::steady_clock::now();
   std::cout << test::getTime(start, stop);

   /*size_t harmonicLength = width;
   size_t hostPitch = harmonicLength * sizeof(real);
   size_t harmonicCount = height;

   real* aDev;
   real* bDev;
   real* cDev;

   size_t aPitch;
   size_t bPitch;
   size_t cPitch;

   cudaMallocPitch<real>(&aDev, &aPitch, hostPitch, harmonicCount);
   cudaMallocPitch<real>(&bDev, &bPitch, hostPitch, harmonicLength);
   cudaMallocPitch<real>(&cDev, &cPitch, hostPitch, harmonicCount);

   cudaMemcpy2D(
      aDev, aPitch,
      a.data(), hostPitch, hostPitch, harmonicCount,
      cudaMemcpyHostToDevice);

   cudaMemcpy2D(
      bDev, bPitch,
      b.data(), hostPitch, hostPitch, harmonicLength,
      cudaMemcpyHostToDevice);

   int m = harmonicLength;
   int k = harmonicLength;
   int n = harmonicCount;
   int lda = aPitch / sizeof(real);
   int ldb = bPitch / sizeof(real);
   int ldc = cPitch / sizeof(real);
   const real alpha = 1;
   const real beta = 0;

   cublasHandle_t handle;
   cublasCreate(&handle);

   auto start = std::chrono::steady_clock::now();
   cublasSgemm_v2(handle, CUBLAS_OP_N, CUBLAS_OP_N, m, n, k, &alpha,
                  aDev, lda, bDev, ldb, &beta, cDev, ldc);
   auto stop = std::chrono::steady_clock::now();

   std::cout << test::getTime(start, stop);

   cublasDestroy(handle);

   cudaMemcpy2D(
      c2.data(), hostPitch,
      cDev, cPitch, hostPitch, harmonicCount,
      cudaMemcpyDeviceToHost);

   cudaFree(aDev);
   cudaFree(bDev);
   cudaFree(cDev);*/
}

void cylinderSurfaceAreaTest()
{
   auto quadratures = test::quadraturesFromCylinder();

   std::cout << abs(math::calcSurfaceArea(quadratures) - math::PI * 8);
}

int main()
{
   //NMResearch2();
   //timeResearchForMorePoints();

   //comparisonToTelmaIntegrals();

   //octreeFormingTime();
   //calculationTimeForMultipolesInLeaves();
   //comparisonBetweenMethodsOnPrecision();

   //calculationTimeForLocalMultipolesByNodeCount();

   //layerCalculationsPrecision();
   //matrixCalculationsPrecision();
   
   //multipoleToLocalTest();

   //layerCalculationTime();
   //matrixCalculationTime();
   //layerMatrixCalculationTime(Device::CPU);
   //layerMatrixCalculationTime(Device::GPU);

   //translationTest2();

   //FMMPrecisionTest();
   //FMMTimeTest();

   //NMResearch2();

   //timeForFullFMMByQuadratures();
   //timeForFullFMMByPointCount();
   //timeForTallCube();

   //BApproximationOnCylinder();
   FMMAndBEM();

   //stridedMatricesTest();

   //cylinderSurfaceAreaTest();
}
#include "math.hpp"
#include "harmonics.hpp"
#include "iomanip"

namespace math
{
   Vector3 cylindricToCartesian(const Vector3& point)
   {
      return  {
         point.y * std::cos(point.x),
         point.y * std::sin(point.x),
         point.z };
   }

   real calcFactorial(int n)
   {
      return n <= 0 ? 1 : n * calcFactorial(n - 1);
   }

   real calcBinomial(int k, int n)
   {
       return Harmonics::getFactorial(n) / (Harmonics::getFactorial(k) * 
                                            Harmonics::getFactorial(n - k));
   }

   real randBetween(real min, real max)
   {
      return (real)std::rand() / RAND_MAX * (max - min) + min;
   }

   size_t nextDevisible(const size_t number, const size_t devidor)
   {
      if(devidor == 0)
         return number;
      else
         return (number + devidor - 1) / devidor * devidor;
   }

   Box getBoundingBox(const std::vector<Vector3>& points)
   {
      real maxX = math::max(points, 0);
      real maxY = math::max(points, 1);
      real maxZ = math::max(points, 2);

      real minX = math::min(points, 0);
      real minY = math::min(points, 1);
      real minZ = math::min(points, 2);

      Vector3 halfDim(
         (maxX - minX) / 2 + 1e-5,
         (maxY - minY) / 2 + 1e-5,
         (maxZ - minZ) / 2 + 1e-5);

      Vector3 center(minX + halfDim.x, minY + halfDim.y, minZ + halfDim.z);

      return { center, halfDim * 1.1 };
   }
}

real math::max(const std::vector<Vector3>& vec, size_t axis)
{
   real res = -1e+16;

   for(size_t i = 0; i < vec.size(); i++)
   {
      if(vec[i][axis] > res)
         res = vec[i][axis];
   }

   return res;
}

real math::min(const std::vector<Vector3>& vec, size_t axis)
{
   real res = 1e+16;

   for(size_t i = 0; i < vec.size(); i++)
   {
      if(vec[i][axis] < res)
         res = vec[i][axis];
   }

   return res;
}

real getReal(const Complex& complex)
{
#ifdef REAL_IS_FLOAT
   return cuCrealf(complex);
#else
   return cuCreal(complex);
#endif
}

real getImag(const Complex& complex)
{
#ifdef REAL_IS_FLOAT
   return cuCimagf(complex);
#else
   return cuCimag(complex);
#endif
}

Complex makeComplex(real realPart, real imagPart)
{
#ifdef REAL_IS_FLOAT
   return make_cuComplex(realPart, imagPart);
#else
   return make_cuDoubleComplex(realPart, imagPart);
#endif
}

Complex operator*(const Complex& lhs, const Complex& rhs)
{
#ifdef REAL_IS_FLOAT
   return cuCmulf(lhs, rhs);
#else
   return cuCmul(lhs, rhs);
#endif
}

__all__ Complex operator*(const Complex& lhs, const real rhs)
{
#ifdef REAL_IS_FLOAT
   return make_cuComplex(cuCrealf(lhs) * rhs, cuCimagf(lhs) * rhs);
#else
   return make_cuDoubleComplex(cuCreal(lhs) * rhs, cuCimag(lhs) * rhs);
#endif
}

Complex operator+(const Complex& lhs, const Complex& rhs)
{
#ifdef REAL_IS_FLOAT
   return cuCaddf(lhs, rhs);
#else
   return cuCadd(lhs, rhs);
#endif
}

__all__ Complex operator-(const Complex& lhs, const Complex& rhs)
{
#ifdef REAL_IS_FLOAT
   return cuCsubf(lhs, rhs);
#else
   return cuCsub(lhs, rhs);
#endif
}

Complex& operator*=(Complex& lhs, const Complex& rhs)
{
   lhs = lhs * rhs;
   return lhs;
}

Complex& operator+=(Complex& lhs, const Complex& rhs)
{
   lhs = lhs + rhs;
   return lhs;
}

std::ostream& operator<<(std::ostream& os, const Complex& val)
{
   os << "(" << std::setw(10) << val.x << ", " << std::setw(10) << val.y << ")";
   return os;
}
#pragma once
#include <vector>
#include <ostream>
#include "real.hpp"
#include "cuda_runtime.h"
#include "typedefs.hpp"
#include "vector3.cuh"
#include "box.hpp"

namespace math
{
   constexpr real PI = 3.14159265359;
   constexpr real MU0 = 1.2566370614e-6;
   constexpr real eps = 1e-3;
   const real SQRT_2 = sqrt(2.0);
   __device__ constexpr real R_SQRT_2 = 0.70710678118;

   Vector3 cylindricToCartesian(const Vector3& point);

   real calcFactorial(int n);
   real calcBinomial(int k, int n);
   real randBetween(real min, real max);
   size_t nextDevisible(const size_t number, const size_t devidor);
   Box getBoundingBox(const std::vector<Vector3>& points);

   template <class T>
   constexpr __all__ int sign(T val)
   {
      return (T(0) < val) - (val < T(0));
   }

   template <class T>
   T mult(
      const std::vector<T>& a,
      const std::vector<T>& b)
   {
      T res = 0;

      for(size_t i = 0; i < a.size(); i++)
      {
         res += a[i] * b[i];
      }
      
      return res;
   }

   template <class T>
   std::vector<T> mult(
      const Matrix<T>& a,
      const std::vector<T>& b)
   {
      std::vector<T> res(b.size());

      for(size_t y = 0; y < a.size(); y++)
      {
         for(size_t x = 0; x < b.size(); x++)
         {
            res[y] += a[y][x] * b[x];
         }
      }

      return res;
   }

   template <class T>
   std::vector<T> mult(
      const std::vector<T>& a,
      const Matrix<T>& b)
   {
      std::vector<T> res(b[0].size());

      for(size_t column = 0; column < b[0].size(); column++)
      {
         for(size_t row = 0; row < a.size(); row++)
         {
            res[column] += a[row] * b[row][column];
         }
      }

      return res;
   }

   template <class T>
   std::vector<T> multMatricesAsVectors(
      const std::vector<T>& a,
      const std::vector<T>& b,
      size_t aWidth,
      size_t aHeight,
      size_t bWidth)
   {
      std::vector<T> res(aHeight * bWidth);

      for(size_t i = 0; i < aHeight; i++)
      {
         for(size_t j = 0; j < bWidth; j++)
         {
            for(size_t k = 0; k < aWidth; k++)
            {
               res[i * bWidth + j] += a[i * aWidth + k] * b[k * bWidth + j];
            }
         }
      }

      return res;
   }

   template <class T>
   Matrix<T> mult(
      const Matrix<T>& a,
      const Matrix<T>& b)
   {
      Matrix<T> res(a.size(), std::vector<T>(b[0].size()));

      for(size_t i = 0; i < a.size(); i++)
      {
         for(size_t j = 0; j < b[0].size(); j++)
         {
            for(size_t k = 0; k < b.size(); k++)
            {
               res[i][j] += a[i][k] * b[k][j];
            }
         }
      }

      return res;
   }

   template<class T>
   std::vector<T> getColumn(const Matrix<T>& matrix, int idx)
   {
      std::vector<T> res(matrix.size());

      for(size_t i = 0; i < matrix.size(); i++)
      {
         res[i] = matrix[i][idx];
      }

      return res;
   }

   template<class T>
   std::vector<T> getColumn(
      const std::vector<T>& matrix,
      const size_t width,
      const size_t height,
      const size_t padding,
      const int idx)
   {
      const size_t currentWidth = nextDevisible(width, padding);
      std::vector<T> res(height);

      for(size_t i = 0; i < height; i++)
      {
         res[i] = matrix[i * currentWidth + idx];
      }

      return res;
   }

   template<class T>
   std::vector<T> getRow(
      const std::vector<T>& matrix,
      const size_t width,
      const size_t padding,
      const int idx)
   {
      const size_t currentWidth = nextDevisible(width, padding);
      std::vector<T> res(matrix.begin() + idx * currentWidth,
          matrix.begin() + idx * currentWidth + width);

      return res;
   }

   template<class T>
   std::vector<T> matrixToVector(const Matrix<T>& matrix, const size_t padding)
   {
      const size_t height = math::nextDevisible(matrix.size(), padding);
      const size_t width = math::nextDevisible(matrix[0].size(), padding);
      std::vector<T> res(height * width);

      for(size_t i = 0; i < matrix.size(); i++)
      {
         for(size_t j = 0; j < matrix[0].size(); j++)
         {
            res[i * width + j] = matrix[i][j];
         }
      }

      return res;
   }

   template<class T>
   Matrix<T> vectorToMatrix(
      const std::vector<T>& vector,
      const size_t height,
      const size_t width,
      const size_t padding)
   {
      const size_t currentWidth = math::nextDevisible(width, padding);
      Matrix<T> res(height, std::vector<T>(width));

      for(size_t i = 0; i < height; i++)
      {
         for(size_t j = 0; j < width; j++)
         {
            res[i][j] = vector[i * currentWidth + j];
         }
      }

      return res;
   }

   template<class T>
   void translateSquareMatrix(Matrix<T>& matrix)
   {
      for(size_t i = 0; i < matrix.size(); i++)
      {
         for(size_t j = 0; j < i; j++)
         {
            std::swap(matrix[i][j], matrix[j][i]);
         }
      }
   }
   
   real max(const std::vector<Vector3>& vec, size_t axis);
   real min(const std::vector<Vector3>& vec, size_t axis);

   template<class T>
   T sum(const std::vector<T>& vec)
   {
      T res = 0;

      for(size_t i = 0; i < vec.size(); i++)
      {
         res += vec[i];
      }

      return res;
   }

   template<class T>
   T mean(const std::vector<T>& vec)
   {
      return sum(vec) / vec.size();
   }
}

template <class T>
std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec)
{
   for(size_t i = 0; i < vec.size(); i++)
   {
      os << vec[i] << " ";
   }

   return os;
}

template <class T>
std::ostream& operator<<(std::ostream& os, const Matrix<T>& matrix)
{
   for(size_t i = 0; i < matrix.size(); i++)
   {
      os << matrix[i] << std::endl;
   }

   return os;
}

__all__ real getReal(const Complex& complex);
__all__ real getImag(const Complex& complex);
__all__ Complex makeComplex(real realPart, real imagPart);
__all__ Complex operator*(const Complex& lhs, const Complex& rhs);
__all__ Complex operator*(const Complex& lhs, real rhs);
__all__ Complex operator+(const Complex& lhs, const Complex& rhs);
__all__ Complex operator-(const Complex& lhs, const Complex& rhs);
__all__ Complex& operator*=(Complex& lhs, const Complex& rhs);
__all__ Complex& operator+=(Complex& lhs, const Complex& rhs);

std::ostream& operator<<(std::ostream& os, const Complex& val);#include <iostream>
#include <chrono>
#include <iomanip>
#include <fstream>

#include "cblas.h"
#include "multipole_solver.hpp"

#include <queue>

#include "math.hpp"
#include "integration.hpp"
#include "harmonics.hpp"
#include "translation_algorithms.hpp"
#include "kernels.cuh"
#include "testing_helpers.hpp"
#include "multipole_translator.hpp"
#include "blass_callers.hpp"

MultipoleSolver::MultipoleSolver(
   std::vector<Quadrature>& quadratures,
   Problem problem,
   size_t quadratureOctreeLeafCapacity) :
   quadratureOctreeLeafCapacity(quadratureOctreeLeafCapacity),
   _problem(problem)
{
   _quadratures.reserve(quadratures.size());

   for(auto& quadrature : quadratures)
   {
      _quadratures.emplace_back(&quadrature);
   }

   initTrees();
   initTransitionMatrices();
}

MultipoleSolver::MultipoleSolver(
   std::vector<BEMQuadrature>& quadratures,
   Problem problem,
   size_t quadratureOctreeLeafCapacity) :
   quadratureOctreeLeafCapacity(quadratureOctreeLeafCapacity),
   _problem(problem)
{
   _quadratures.reserve(quadratures.size());

   for(auto& quadrature : quadratures)
   {
      _quadratures.emplace_back(&quadrature);
   }

   initTrees();
   initTransitionMatrices();
}

void MultipoleSolver::calcMultipoleExpansionsAtLeaves()
{
   std::queue<QuadratureOctreeNode*> qq;

   qq.push(_quadratureOctreeRoot);
   
   while(!qq.empty())
   {
      auto currentNode = qq.front();
      qq.pop();
      
      if(currentNode->isUsefullLeaf())
      {
         switch(_problem)
         {
            case Problem::BioSavartLaplace:
            {
               currentNode->multipoleExpansion() = math::calcIntegralContribution(
                  currentNode->quadratures(), harmonicOrder, currentNode->box().center());
               break;
            }
            case Problem::BEM:
            {
               currentNode->multipoleExpansion() = math::calcBEMIntegralContribution(
                  currentNode->quadratures(), harmonicOrder, currentNode->box().center());
               break;
            }
         }
      }
      else
      {
         for (auto child : currentNode->children())
         {
            qq.push(child);
         }
      }
   }
   
   _multipolesAtLeavesAreReady = true;
}

size_t MultipoleSolver::getQuadratureOctreeNodeCount() const
{
   return _quadratureOctreeRoot->getAllNodeCount();
}

void MultipoleSolver::calclMultipoleExpansions(M2MAlg algorithm, Device device)
{
   if(!_multipolesAtLeavesAreReady)
   {
      calcMultipoleExpansionsAtLeaves();
   }

   switch(algorithm)
   {
      case M2MAlg::NoTranslation:
      {
         calcMultipoleExpansionsWithoutTranslation();
         break;
      }
      case M2MAlg::ComplexTranslation:
      {
         calcMultipoleExpansionsWithComplexTranslation();
         break;
      }
      case M2MAlg::RealTranslation:
      {
         calcMultipoleExpansionsWithRealTranslation();
         break;
      }
      case M2MAlg::Layers:
      {
         calcMultipoleExpanstionsWithLayersOrMatrices(device, false);
         break;
      }
      case M2MAlg::Matrices:
      {
         calcMultipoleExpanstionsWithLayersOrMatrices(device, true);
         break;
      }
   }

   _multipolesAreReady = true;
}

void MultipoleSolver::calcMultipoleExpansionsWithoutTranslation()
{
   std::queue<QuadratureOctreeNode*> qq;

   qq.push(_quadratureOctreeRoot);

   while(!qq.empty())
   {
      auto currentNode = qq.front();
      qq.pop();

      if(!currentNode->isUsefullLeaf())
      {
         currentNode->multipoleExpansion() = math::calcIntegralContribution(
            currentNode->getAllQuadratures(),
            harmonicOrder,
            currentNode->box().center());

         for(auto child : currentNode->children())
         {
            qq.push(child);
         }
      }
   }
}

void MultipoleSolver::calcMultipoleExpansionsWithComplexTranslation()
{
   _quadratureOctreeRoot->calcMultipoleExpansionsWithComplexTranslation(harmonicOrder);
}

void MultipoleSolver::calcMultipoleExpansionsWithRealTranslation()
{
   _quadratureOctreeRoot->calcMultipoleExpansionsWithRealTranslation(harmonicOrder);
}

void MultipoleSolver::calcMultipoleExpanstionsWithLayersOrMatrices(
   Device device,
   bool useMatrices)
{
   std::vector<std::vector<QuadratureOctreeNode*>> layers;
   enumerateNodes(_quadratureOctreeRoot, layers, 0);
   _quadratureOctreeRoot->initAllMultipoleExpansions(harmonicOrder);

   if(log)
   {
      if(useMatrices)
         std::cout << "-----------------------matrices------------------------" << std::endl;
      else
         std::cout << "------------------------layers-------------------------" << std::endl;

      std::cout << std::setw(10) << "layer" << std::setw(15) << "mlpl count";
      std::cout << std::setw(15) << "kernel time" << std::setw(15) << "total time" << std::endl;
      std::cout << "-------------------------------------------------------" << std::endl;
      std::cout << std::fixed;
   }

   calcContributionsToHigherLayers(layers, device, useMatrices);
}

void MultipoleSolver::enumerateNodes(
   QuadratureOctreeNode* node,
   std::vector<std::vector<QuadratureOctreeNode*>>& layers,
   size_t currentLayerId)
{
   if(node->isUsefullLeaf() || node->isSubdivided())
   {
      if(layers.size() <= currentLayerId)
         layers.emplace_back(std::vector<QuadratureOctreeNode*>());

      layers[currentLayerId].push_back(node);

      for(auto child : node->children())
      {
         enumerateNodes(child, layers, currentLayerId + 1);
      }
   }
}

void MultipoleSolver::calcContributionsToHigherLayers(
   const std::vector<std::vector<QuadratureOctreeNode*>>& layers,
   Device device,
   bool useMatrices)
{
   useMatrices ? calcContributionsToHigherLevelsWithMatrices(layers, device) :
      calcContributionsToHigherLayers(layers, device);
}

void MultipoleSolver::calcContributionsToHigherLayers(
   const std::vector<std::vector<QuadratureOctreeNode*>>& layers,
   Device device)
{
   for(size_t l = layers.size() - 1; l >= 1; l--)
   {
      auto start = std::chrono::steady_clock::now();

      if(log)
      {
         std::cout << std::setw(10) << l << std::setw(15) << layers[l].size();
      }

      std::vector<Vector3> contributions =
         calcContributionsToHigherLayer(layers[l], device);

      for(size_t c = 0; c < layers[l].size(); c++)
      {
         for(int h = 0; h < harmonicLength; h++)
         {
            layers[l][c]->parent()->multipoleExpansion().getHarmonic(h) +=
               contributions[c * harmonicLength + h];
         }
      }

      auto stop = std::chrono::steady_clock::now();
      double time = test::getTime(start, stop);

      if(log)
      {
         std::cout << std::setw(15) << time << std::endl;
      }
   }
}

std::vector<Vector3> MultipoleSolver::calcContributionsToHigherLayer(
   const std::vector<QuadratureOctreeNode*>& layer,
   Device device)
{
   std::vector<Vector3> harmonics(layer.size() * harmonicLength);
   std::vector<real> regulars(layer.size() * harmonicLength);

   for(size_t i = 0; i < layer.size(); i++)
   {
      Vector3 translation = layer[i]->box().center() - layer[i]->parent()->box().center();
      auto regular = Harmonics::calcRegularSolidHarmonics(harmonicOrder, translation);

      std::copy(regular.data().begin(), 
                regular.data().end(),
                regulars.begin() + i * harmonicLength);

      std::copy(layer[i]->multipoleExpansion().data().begin(), 
                layer[i]->multipoleExpansion().data().end(),
                harmonics.begin() + i * harmonicLength);
   }

   std::vector<Vector3> result(layer.size() * harmonicLength);

   auto start = std::chrono::steady_clock::now();

   switch(device)
   {
      case Device::CPU:
      {
         kernels::translateAllCPU(
            result.data(),
            regulars.data(),
            harmonics.data(),
            layer.size(),
            harmonicOrder);

         break;
      }
      case Device::GPU:
      {
         kernels::translateAllGPU(
            result.data(),
            regulars.data(),
            harmonics.data(),
            layer.size(),
            harmonicOrder);

         break;
      }
      case Device::Adaptive:
      {
         break;
      }
   }

   auto stop = std::chrono::steady_clock::now();
   double layerTime = test::getTime(start, stop);

   if(log)
   {
      std::cout << std::setw(15) << layerTime;
   }

   return result;
}

void MultipoleSolver::calcContributionsToHigherLevelsWithMatrices(
   const std::vector<std::vector<QuadratureOctreeNode*>>& layers,
   Device device)
{
   for(size_t l = layers.size() - 1; l >= 1; l--)
   {
      double kernelTime = 0;

      auto start = std::chrono::steady_clock::now();

      if(log)
      {
         std::cout << std::setw(10) << l << std::setw(15) << layers[l].size();
      }

      auto& layer = layers[l];
      auto nodesByOrientation = separateNodesByOrientation(layer);
      auto regularVectors = calcRegularMatricesForM2MAsVectors(
         nodesByOrientation);
      
      for(size_t o = 0; o < 8; o++)
      {
         if(!nodesByOrientation[o].empty())
         {
            size_t nodesCount = nodesByOrientation[o].size();

            auto expansionVectors =
               getExpansionsInOneOrientationAsVectors(
                  nodesByOrientation[o]);

            RealMatrix translated(3, std::vector<real>(harmonicLength * nodesCount));

            switch(device)
            {
               case Device::CPU:
               {
                  for(size_t c = 0; c < 3; c++)
                  {
                     auto kernelStart = std::chrono::steady_clock::now();

                     kernels::translateAllCPUMatrixBLAS(
                        translated[c].data(),
                        expansionVectors[c].data(),
                        regularVectors[o].data(),
                        nodesCount,
                        harmonicOrder);

                     auto kernelStop = std::chrono::steady_clock::now();
                     kernelTime += std::chrono::duration_cast<std::chrono::microseconds>
                        (kernelStop - kernelStart).count() * 1e-6;
                  }

                  break;
               }
               case Device::GPU:
               {
                  kernels::translateAllGPUMatrixCuBLAS(
                     translated,
                     expansionVectors,
                     regularVectors[o].data(),
                     nodesCount,
                     harmonicOrder);

                  break;
               }
            }
            
            accountChildrenContributions(
               nodesByOrientation[o],
               translated);
         }
      }

      auto stop = std::chrono::steady_clock::now();
      double layerTime = test::getTime(start, stop);

      if(log)
      {
         std::cout << std::setw(15) << kernelTime;
         std::cout << std::setw(15) << layerTime << std::endl;
      }
   }
}

Matrix<QuadratureOctreeNode*> MultipoleSolver::separateNodesByOrientation(
   const std::vector<QuadratureOctreeNode*>& layer)
{
   Matrix<QuadratureOctreeNode*> res(8);

   for(auto node : layer)
   {
      for(size_t i = 0; i < 8; i++)
      {
         if(node->parent()->children()[i] == node)
         {
            res[i].push_back(node);
            break;
         }
      }
   }

   return res;
}

std::vector<ComplexMatrix> MultipoleSolver::calcRegularMatricesForLayer(
   const Matrix<QuadratureOctreeNode*>& nodesByOrientation)
{
   std::vector<ComplexMatrix> res;
   res.reserve(8);

   for(size_t i = 0; i < 8; i++)
   {
      auto parent = nodesByOrientation[i][0]->parent();

      if(!nodesByOrientation[i].empty())
      {
         auto translation = 
            nodesByOrientation[i][0]->box().center() - parent->box().center();

         auto regularHarmonics = Harmonics::calcRegularSolidHarmonics(
            harmonicOrder,
            translation);

         res.emplace_back(formMatrixFromRegularHarmonics(
            Harmonics::realToComplex(regularHarmonics)));
      }
   }

   return res;
}

RealMatrix MultipoleSolver::calcRegularMatricesForM2MAsVectors(
   const Matrix<QuadratureOctreeNode*>& nodesByOrientation)
{
   size_t matrixElemCount = harmonicLength * harmonicLength;

   RealMatrix result(8, std::vector<real>(matrixElemCount));

   for(int i = 0; i < 8; i++)
   {
      auto parent = nodesByOrientation[i][0]->parent();

      auto translation = nodesByOrientation[i][0]->box().center() -
         parent->box().center();

      auto regularHarmonics = Harmonics::calcRegularSolidHarmonics(
         harmonicOrder, translation);

      auto regularHarmonicsMatrix = formMatrixFromRegularHarmonicsForM2MAsVectors(
         Harmonics::realToComplex(regularHarmonics));

      Complex alpha = makeComplex(1, 0);
      Complex beta = makeComplex(0, 0);

      std::vector<Complex> temp1(matrixElemCount);

      blas::multComplexMatrices(
         CBLAS_ORDER::CblasRowMajor,
         CBLAS_TRANSPOSE::CblasNoTrans,
         CBLAS_TRANSPOSE::CblasNoTrans,
         harmonicLength, harmonicLength, harmonicLength,
         (real*)&alpha,
         (real*)_realToComplexMatrix.data(),
         harmonicLength,
         (real*)regularHarmonicsMatrix.data(),
         harmonicLength,
         (real*)&beta,
         (real*)temp1.data(),
         harmonicLength);

      std::vector<Complex> temp2(matrixElemCount);

      blas::multComplexMatrices(
         CBLAS_ORDER::CblasRowMajor,
         CBLAS_TRANSPOSE::CblasNoTrans,
         CBLAS_TRANSPOSE::CblasNoTrans,
         harmonicLength, harmonicLength, harmonicLength,
         (real*)&alpha,
         (real*)temp1.data(),
         harmonicLength,
         (real*)_complexToRealMatrix.data(),
         harmonicLength,
         (real*)&beta,
         (real*)temp2.data(),
         harmonicLength);

      blas::copyVector(
         matrixElemCount,
         (real*)(temp2.data()), 2,
         result[i].data(), 1);
   }

   return result;
}

ComplexMatrix MultipoleSolver::formMatrixFromRegularHarmonics(
   const ComplexHarmonicSeries& regular)
{
   ComplexMatrix res(
      regular.elemCount(),
      std::vector<Complex>(regular.elemCount()));

   for(int l = 0; l <= regular.order(); l++)
   {
      for(int m = -l; m <= l; m++)
      {
         for(int lambda = 0; lambda <= l; lambda++)
         {
            int dl = l - lambda;

            for(int mu = -lambda; mu <= lambda; mu++)
            {
               int dm = m - mu;

               if(-dl <= dm && dm <= dl)
               {
                  res[dl * dl + dl + dm][l * l + l + m] =
                     regular.getHarmonic(lambda * lambda + lambda + mu) *
                     MultipoleTranslator::multipoleTranslationFactor(m, mu);
               }
            }
         }
      }
   }

   return res;
}

std::vector<Complex> MultipoleSolver::formMatrixFromRegularHarmonicsForM2MAsVectors(
   const ComplexHarmonicSeries& regular)
{
   std::vector<Complex> res(harmonicLength * harmonicLength);

   for(int l = 0; l <= regular.order(); l++)
   {
      for(int m = -l; m <= l; m++)
      {
         for(int lambda = 0; lambda <= l; lambda++)
         {
            int dl = l - lambda;

            for(int mu = -lambda; mu <= lambda; mu++)
            {
               int dm = m - mu;

               if(-dl <= dm && dm <= dl)
               {
                  res[(l * l + l + m) + (dl * dl + dl + dm) * harmonicLength] =
                     regular.getHarmonic(lambda * lambda + lambda + mu) *
                     MultipoleTranslator::multipoleTranslationFactor(m, mu);
               }
            }
         }
      }
   }

   return res;
}

RealMatrix MultipoleSolver::getExpansionsInOneOrientationAsVectors(
   const std::vector<QuadratureOctreeNode*>& nodesByOrientation)
{
   size_t nodeCount = nodesByOrientation.size();

   RealMatrix res(3, std::vector<real>(harmonicLength * nodeCount));

   for(int nodeId = 0; nodeId < nodesByOrientation.size(); nodeId++)
   {
      auto& expansion = nodesByOrientation[nodeId]->multipoleExpansion();

      for(size_t c = 0; c < 3; c++)
      {
         blas::copyVector(
            harmonicLength,
            (real*)expansion.data().data() + c, 3,
            res[c].data() + nodeId * harmonicLength, 1);
      }
   }

   return res;
}

void MultipoleSolver::accountChildrenContributions(
   const std::vector<QuadratureOctreeNode*>& nodesByOrientation,
   const RealMatrix& contributions)
{
   for(int nodeId = 0; nodeId < nodesByOrientation.size(); nodeId++)
   {
      auto parent = nodesByOrientation[nodeId]->parent();

      for(size_t c = 0; c < 3; c++)
      {
         blas::addVectorToVector(
            harmonicLength, 1, 
            contributions[c].data() + harmonicLength * nodeId, 1,
            (real*)(parent->multipoleExpansion().data().data()) + c, 3);
      }
   }
}

void MultipoleSolver::printMatrices(
   const std::vector<ComplexMatrix>& regularMatrices,
   const std::vector<ComplexMatrix>& expansionMatrices)
{
   for(size_t i = 0; i < 8; i++)
   {
      operator<<(std::ofstream("matrices/regular_" + std::to_string(i) +".txt"), 
                 regularMatrices[i]);
   }

   operator<<(std::ofstream("matrices/expansion_x.txt"), expansionMatrices[0]);
   operator<<(std::ofstream("matrices/expansion_y.txt"), expansionMatrices[1]);
   operator<<(std::ofstream("matrices/expansion_z.txt"), expansionMatrices[2]);
}

void MultipoleSolver::initTrees()
{
   switch(_problem)
   {
      case Problem::BioSavartLaplace:
      {
         _quadratureOctreeRoot = new QuadratureOctreeNode(
            Box(Vector3(0, 0, 0), Vector3(3, 3, 3)), quadratureOctreeLeafCapacity);
         break;
      }
      case Problem::BEM:
      {
         _quadratureOctreeRoot = new QuadratureOctreeNode(
            Box(Vector3(0, 0, 0), Vector3(1.1, 1.1, 1.6)), quadratureOctreeLeafCapacity);
         break;
      }
   }

   _quadratureOctreeRoot->insert(_quadratures);
}

void MultipoleSolver::initTransitionMatrices()
{
   _realToComplexMatrix = Harmonics::calcRealToComplexTransitionMatrix1D(
      harmonicOrder);

   _complexToRealMatrix = Harmonics::calcComplexToRealTransitionMatrix1D(
      harmonicOrder);
}

Vector3 MultipoleSolver::calcA(real current, const Vector3& point)
{
   if(!_multipolesAreReady)
      throw new std::exception("Multipoles are not ready!");

   return _quadratureOctreeRoot->calcA(point) / (4.0 * math::PI) * current;
}

Vector3 MultipoleSolver::calcB(real current, const Vector3& point)
{
   if(!_multipolesAreReady)
      throw new std::exception("Multipoles are not ready!");

   return _quadratureOctreeRoot->calcRot(point) / (4.0 * math::PI) * current * math::MU0;
}

MultipoleSolver::~MultipoleSolver()
{
   delete _quadratureOctreeRoot;
}#pragma once
#include <vector>
#include "vector3.cuh"
#include "basis_quadratures.hpp"
#include "bem_quadrature.hpp"
#include "harmonics.hpp"
#include "quadrature.hpp"
#include "quadrature_octree.hpp"
#include "typedefs.hpp"
#include "multipole_solver_enums.hpp"

class MultipoleSolver
{
protected:
   std::vector<Quadrature*> _quadratures;
   QuadratureOctreeNode* _quadratureOctreeRoot = nullptr;
   bool _multipolesAreReady = false;
   bool _multipolesAtLeavesAreReady = false;
   std::vector<Complex> _realToComplexMatrix;
   std::vector<Complex> _complexToRealMatrix;
   Problem _problem;

public:
   bool log = false;
   const int harmonicOrder = 10;
   const int harmonicLength = (harmonicOrder + 1) * (harmonicOrder + 1);
   const size_t quadratureOctreeLeafCapacity;

   MultipoleSolver(
      std::vector<Quadrature>& quadratures,
      Problem problem = Problem::BioSavartLaplace,
      size_t quadratureOctreeLeafCapacity = 1000);

   MultipoleSolver(
      std::vector<BEMQuadrature>& quadratures,
      Problem problem = Problem::BioSavartLaplace,
      size_t quadratureOctreeLeafCapacity = 1000);

   virtual void calcMultipoleExpansionsAtLeaves();
   virtual size_t getQuadratureOctreeNodeCount() const;

   virtual void calclMultipoleExpansions(
      M2MAlg algorithm,
      Device device = Device::CPU);
   
   virtual Vector3 calcA(real current, const Vector3& point);
   virtual Vector3 calcB(real current, const Vector3& point);
   virtual ~MultipoleSolver();

protected:
   virtual void calcMultipoleExpansionsWithoutTranslation();
   virtual void calcMultipoleExpansionsWithComplexTranslation();
   virtual void calcMultipoleExpansionsWithRealTranslation();

   virtual void calcMultipoleExpanstionsWithLayersOrMatrices(
      Device device,
      bool useMatrices);

   virtual void enumerateNodes(
      QuadratureOctreeNode* node,
      std::vector<std::vector<QuadratureOctreeNode*>>& layers, 
      size_t currentLayerId);

   virtual void calcContributionsToHigherLayers(
      const std::vector<std::vector<QuadratureOctreeNode*>>& layers,
      Device device,
      bool useMatrices);

   virtual void calcContributionsToHigherLayers(
      const std::vector<std::vector<QuadratureOctreeNode*>>& layers,
      Device device);

   virtual std::vector<Vector3> calcContributionsToHigherLayer(
      const std::vector<QuadratureOctreeNode*>& layer,
      Device device);

   virtual void calcContributionsToHigherLevelsWithMatrices(
      const std::vector<std::vector<QuadratureOctreeNode*>>& layers,
      Device device);
   
   virtual Matrix<QuadratureOctreeNode*> separateNodesByOrientation(
      const std::vector<QuadratureOctreeNode*>& layer);

   virtual std::vector<ComplexMatrix> calcRegularMatricesForLayer(
      const Matrix<QuadratureOctreeNode*>& nodesByOrientation);

   virtual RealMatrix calcRegularMatricesForM2MAsVectors(
      const Matrix<QuadratureOctreeNode*>& nodesByOrientation);

   virtual ComplexMatrix formMatrixFromRegularHarmonics(
      const ComplexHarmonicSeries& regular);

   virtual std::vector<Complex> formMatrixFromRegularHarmonicsForM2MAsVectors(
      const ComplexHarmonicSeries& regular);

   virtual RealMatrix getExpansionsInOneOrientationAsVectors(
      const std::vector<QuadratureOctreeNode*>& nodesByOrientation);

   virtual void accountChildrenContributions(
      const std::vector<QuadratureOctreeNode*>& nodesByOrientation,
      const RealMatrix& contributions);

   virtual void printMatrices(
      const std::vector<ComplexMatrix>& regularMatrices,
      const std::vector<ComplexMatrix>& expansionMatrices);

   virtual void initTrees();
   virtual void initTransitionMatrices();
};﻿#pragma once

enum class M2MAlg
{
   NoTranslation = 0,
   ComplexTranslation,
   RealTranslation,
   Layers,
   Matrices,
};

enum class Device
{
   CPU = 0,
   GPU,
   Adaptive
};


enum class M2LAlg
{
   ComplexTranslation = 0,
   Matrices,
};

enum class Problem
{
   BioSavartLaplace = 0,
   BEM,
};#include "multipole_translator.hpp"

ComplexHarmonicSeries MultipoleTranslator::translateMultipole(
   const ComplexHarmonicSeries& a,
   const ComplexHarmonicSeries& b)
{
   ComplexHarmonicSeries res(a.order());

   for(int l = 0; l <= a.order(); l++)
   {
      for(int m = -l; m <= l; m++)
      {
         for(int lambda = 0; lambda <= l; lambda++)
         {
            int dl = l - lambda;

            for(int mu = -lambda; mu <= lambda; mu++)
            {
               int dm = m - mu;

               if(dm >= -dl && dm <= +dl)
               {
                  res.getHarmonic(l, m) += a.getHarmonic(lambda, mu) *
                     b.getHarmonic(dl, dm) * multipoleTranslationFactor(m, mu);
               }
            }
         }
      }
   }

   return res;
}

RealHarmonicSeries MultipoleTranslator::translateMultipole(
   const RealHarmonicSeries& a,
   const RealHarmonicSeries& b)
{
   RealHarmonicSeries res(b.order());

   for(int l = 0; l <= b.order(); l++)
   {
      real zeroRes = 0;

      for(int lambda = 0; lambda <= l; lambda++)
      {
         int dl = l - lambda;

         for(int mu = -lambda; mu <= lambda; mu++)
         {
            if(-dl <= mu && mu <= +dl)
            {
               zeroRes += b.getHarmonic(lambda, mu) * a.getHarmonic(dl, mu) *
                  multipoleTranslationFactor(0, mu);
            }
         }
      }

      res.getHarmonic(l, 0) = zeroRes;

      for(int m = 1; m <= l; m++)
      {
         real realRes = 0;
         real imagRes = 0;

         for(int lambda = 0; lambda <= l; lambda++)
         {
            int dl = l - lambda;

            for(int mu = -lambda; mu <= lambda; mu++)
            {
               int dm = m - mu;
               int dnm = -m - mu;

               real RR = b.getReal(lambda, mu);
               real IR = b.getImag(lambda, mu);

               real RM = 0;
               real IM = 0;

               real RnM = 0;
               real InM = 0;

               if(-dl <= dm && dm <= dl)
               {
                  RM = a.getReal(dl, dm);
                  IM = a.getImag(dl, dm);

                  realRes += (RR * RM - IR * IM) * multipoleTranslationFactor(m, mu);
                  imagRes += (RR * IM + IR * RM) * multipoleTranslationFactor(m, mu);
               }

               if(-dl <= dnm && dnm <= dl)
               {
                  RnM = a.getReal(dl, dnm);
                  InM = a.getImag(dl, dnm);

                  realRes += (RR * RnM - IR * InM) * multipoleTranslationFactor(-m, mu);
                  imagRes -= (RR * InM + IR * RnM) * multipoleTranslationFactor(-m, mu);
               }
            }
         }

         res.getHarmonic(l, m) = realRes * math::R_SQRT_2;
         res.getHarmonic(l, -m) = imagRes * math::R_SQRT_2;
      }
   }

   return res;
}

HarmonicSeries<Vector3> MultipoleTranslator::translateMultipoleWithComplex(
   const HarmonicSeries<Vector3>& expansion,
   const Vector3& translation)
{
   auto regular = Harmonics::realToComplex(Harmonics::calcRegularSolidHarmonics(expansion.order(), translation));

   auto xComponent = Harmonics::realToComplex(Harmonics::separateCoord(expansion, 0));
   auto yComponent = Harmonics::realToComplex(Harmonics::separateCoord(expansion, 1));
   auto zComponent = Harmonics::realToComplex(Harmonics::separateCoord(expansion, 2));

   return Harmonics::createFormXYZ(
      Harmonics::complexToReal(translateMultipole(regular, xComponent)),
      Harmonics::complexToReal(translateMultipole(regular, yComponent)),
      Harmonics::complexToReal(translateMultipole(regular, zComponent)));
}

HarmonicSeries<Vector3> MultipoleTranslator::translateMultipoleWithReal(
   const HarmonicSeries<Vector3>& expansion,
   const Vector3& translation)
{
   auto regular = Harmonics::calcRegularSolidHarmonics(expansion.order(), translation);

   auto xComponent = Harmonics::separateCoord(expansion, 0);
   auto yComponent = Harmonics::separateCoord(expansion, 1);
   auto zComponent = Harmonics::separateCoord(expansion, 2);

   return Harmonics::createFormXYZ(
      translateMultipole(regular, xComponent),
      translateMultipole(regular, yComponent),
      translateMultipole(regular, zComponent));
}

real MultipoleTranslator::multipoleTranslationFactor(int m, int mu)
{
   return pow(-1, -0.5 * (abs(m) - abs(mu) - abs(m - mu)));
}

ComplexHarmonicSeries MultipoleTranslator::multipoleToLocal(
   const ComplexHarmonicSeries& a,
   const ComplexHarmonicSeries& b)
{
   ComplexHarmonicSeries res(a.order());

   for(int l = 0; l <= a.order(); l++)
   {
      for(int lambda = 0; lambda <= a.order(); lambda++)
      {
         for(int m = -l; m <= l; m++)
         {
            for(int mu = -lambda; mu <= lambda; mu++)
            {
               int dl = l + lambda;
               int dm = m - mu;

               if(dm >= -dl && dm <= +dl && dl <= a.order())
               {
                  res.getHarmonic(l, m) += a.getHarmonic(lambda, mu) *
                     b.getHarmonic(dl, dm) * multipoleToLocalTranslationFactor(m, mu, lambda);
               }
            }
         }
      }
   }

   return res;
}

HarmonicSeries<Vector3> MultipoleTranslator::multipoleToLocalWithComplex(
   const HarmonicSeries<Vector3>& expansion,
   const Vector3& translation)
{
   auto irregular = Harmonics::realToComplex(
      Harmonics::calcIrregularSolidHarmonics(expansion.order(), translation));

   auto xComponent = Harmonics::realToComplex(Harmonics::separateCoord(expansion, 0));
   auto yComponent = Harmonics::realToComplex(Harmonics::separateCoord(expansion, 1));
   auto zComponent = Harmonics::realToComplex(Harmonics::separateCoord(expansion, 2));

   return Harmonics::createFormXYZ(
      Harmonics::complexToReal(multipoleToLocal(xComponent, irregular)),
      Harmonics::complexToReal(multipoleToLocal(yComponent, irregular)),
      Harmonics::complexToReal(multipoleToLocal(zComponent, irregular)));
}

real MultipoleTranslator::multipoleToLocalTranslationFactor(int m, int mu, int lambda)
{
   return pow(-1, -0.5 * (abs(m - mu) - abs(m) - abs(mu))) * 
      pow(-1, abs(lambda));
}

ComplexHarmonicSeries MultipoleTranslator::translateLocal(
   const ComplexHarmonicSeries& a,
   const ComplexHarmonicSeries& b)
{
   ComplexHarmonicSeries res(a.order());

   for(int l = 0; l <= a.order(); l++)
   {
      for(int lambda = 0; lambda <= a.order(); lambda++)
      {
         if(lambda >= l)
         {
            for(int m = -l; m <= l; m++)
            {
               for(int mu = -lambda; mu <= lambda; mu++)
               {
                  int dl = lambda - l;
                  int dm = m - mu;

                  if(dm >= -dl && dm <= +dl && dl <= a.order())
                  {
                     res.getHarmonic(l, m) += a.getHarmonic(lambda, mu) *
                        b.getHarmonic(dl, dm) * localTranslationFactor(m, mu, lambda, l);
                  }
               }
            }
         }
      }
   }

   return res;
}

HarmonicSeries<Vector3> MultipoleTranslator::translateLocalWithComplex(
   const HarmonicSeries<Vector3>& expansion,
   const Vector3& translation)
{
   auto regular = Harmonics::realToComplex(
      Harmonics::calcRegularSolidHarmonics(expansion.order(), translation));

   auto xComponent = Harmonics::realToComplex(Harmonics::separateCoord(expansion, 0));
   auto yComponent = Harmonics::realToComplex(Harmonics::separateCoord(expansion, 1));
   auto zComponent = Harmonics::realToComplex(Harmonics::separateCoord(expansion, 2));

   return Harmonics::createFormXYZ(
      Harmonics::complexToReal(translateLocal(xComponent, regular)),
      Harmonics::complexToReal(translateLocal(yComponent, regular)),
      Harmonics::complexToReal(translateLocal(zComponent, regular)));
}

real MultipoleTranslator::localTranslationFactor(int m, int mu, int lambda, int l)
{
   return pow(-1, -0.5 * (abs(mu) - abs(m - mu) - abs(m))) *
      pow(-1, abs(lambda) + abs(l));
}#pragma once
#include "harmonics.hpp"

class MultipoleTranslator
{
public:
#pragma region Multipole to multipole translation algorithms

   static ComplexHarmonicSeries translateMultipole(
      const ComplexHarmonicSeries& a,
      const ComplexHarmonicSeries& b);

   static RealHarmonicSeries translateMultipole(
      const RealHarmonicSeries& a,
      const RealHarmonicSeries& b);

   static HarmonicSeries<Vector3> translateMultipoleWithComplex(
      const HarmonicSeries<Vector3>& expansion,
      const Vector3& translation);

   static HarmonicSeries<Vector3> translateMultipoleWithReal(
      const HarmonicSeries<Vector3>& expansion,
      const Vector3& translation);

   static real multipoleTranslationFactor(int m, int mu);

#pragma endregion

#pragma region Multipole to local algorithms

   static ComplexHarmonicSeries multipoleToLocal(
      const ComplexHarmonicSeries& a,
      const ComplexHarmonicSeries& b);

   static HarmonicSeries<Vector3> multipoleToLocalWithComplex(
      const HarmonicSeries<Vector3>& expansion,
      const Vector3& translation);

   static real multipoleToLocalTranslationFactor(int m, int mu, int lambda);

#pragma endregion

#pragma region Local to local transaltion algorithms

   static ComplexHarmonicSeries translateLocal(
      const ComplexHarmonicSeries& a,
      const ComplexHarmonicSeries& b);

   static HarmonicSeries<Vector3> translateLocalWithComplex(
      const HarmonicSeries<Vector3>& expansion,
      const Vector3& translation);

   static real localTranslationFactor(int m, int mu, int lambda, int l);

#pragma endregion
};#include "quadrature.hpp"

Quadrature::Quadrature()
{
}

Quadrature::Quadrature(const Vector3& coordinates, real volume, real weight):
   Vector3(coordinates), weight(volume * weight)
{

}
#pragma once
#include "vector3.cuh"

struct Quadrature : public Vector3
{
   real weight;

   Quadrature();
   Quadrature(const Vector3& coordinates, real volume, real weight);
};#include <thrust/complex.h>
#include <queue>

#include "quadrature_octree.hpp"
#include "integration.hpp"
#include "harmonics.hpp"
#include "multipole_translator.hpp"

QuadratureOctreeNode::QuadratureOctreeNode() : 
   _parent(nullptr)
{
}

QuadratureOctreeNode::QuadratureOctreeNode(
   const Box& box,
   const size_t capacity,
   QuadratureOctreeNode* parent) :
   _parent(parent), _box(box), _capacity(capacity)
{

}

void QuadratureOctreeNode::insert(std::vector<Quadrature*>& points)
{
   for(auto point : points)
   {
      insert(point);
   }
}

void QuadratureOctreeNode::insert(Quadrature* point)
{
   if(!_box.contains(*point))
   {
      return;
   }

   if(_quadratures.size() + 1 < _capacity)
   {
      if(!isSubdivided())
      {
         if(_quadratures.empty())
            _quadratures.reserve(_capacity);

         _quadratures.emplace_back(point);
      }
      else
      {
         for(auto& child : _children)
         {
            child->insert(point);
         }
      }
   }
   else
   {
      subdivide();

      _quadratures.push_back(point);

      for(auto p : _quadratures)
      {
         for(auto& child : _children)
         {
            child->insert(p);
         }
      }

      _quadratures.clear();
      _quadratures.shrink_to_fit();
   }
}

void QuadratureOctreeNode::subdivide()
{
   float x = _box.center().x;
   float y = _box.center().y;
   float z = _box.center().z;

   float w = _box.halfDimensions().x;
   float h = _box.halfDimensions().y;
   float d = _box.halfDimensions().z;

   Vector3 childrenHalfDimensions = { w / 2, h / 2, d / 2 };

   _children.reserve(8);

   _children.emplace_back(new QuadratureOctreeNode(Box({ x - w / 2, y - h / 2, z - d / 2 }, childrenHalfDimensions), _capacity, this));
   _children.emplace_back(new QuadratureOctreeNode(Box({ x + w / 2, y - h / 2, z - d / 2 }, childrenHalfDimensions), _capacity, this));
   _children.emplace_back(new QuadratureOctreeNode(Box({ x + w / 2, y + h / 2, z - d / 2 }, childrenHalfDimensions), _capacity, this));
   _children.emplace_back(new QuadratureOctreeNode(Box({ x - w / 2, y + h / 2, z - d / 2 }, childrenHalfDimensions), _capacity, this));

   _children.emplace_back(new QuadratureOctreeNode(Box({ x - w / 2, y - h / 2, z + d / 2 }, childrenHalfDimensions), _capacity, this));
   _children.emplace_back(new QuadratureOctreeNode(Box({ x + w / 2, y - h / 2, z + d / 2 }, childrenHalfDimensions), _capacity, this));
   _children.emplace_back(new QuadratureOctreeNode(Box({ x + w / 2, y + h / 2, z + d / 2 }, childrenHalfDimensions), _capacity, this));
   _children.emplace_back(new QuadratureOctreeNode(Box({ x - w / 2, y + h / 2, z + d / 2 }, childrenHalfDimensions), _capacity, this));
}

std::vector<Quadrature*> QuadratureOctreeNode::getAllQuadratures() const
{
   std::vector<Quadrature*> result;
   result.insert(result.end(), _quadratures.begin(), _quadratures.end());

   if(isSubdivided())
   {
      for(auto child : _children)
      {
         auto childQudratures = child->getAllQuadratures();
         result.insert(result.end(), childQudratures.begin(), childQudratures.end());
      }
   }

   return result;
}

void QuadratureOctreeNode::calcMultipoleExpansionsWithComplexTranslation(int n)
{
   if(!isUsefullLeaf())
   {
      _multipoleExpansion = HarmonicSeries<Vector3>(n);

      for(auto child : _children)
      {
         child->calcMultipoleExpansionsWithComplexTranslation(n);
      }

      for(auto child : _children)
      {
         if(!child->_quadratures.empty() && !child->isSubdivided() ||
            child->_quadratures.empty() && child->isSubdivided())
            _multipoleExpansion.add(MultipoleTranslator::translateMultipoleWithComplex(
               child->multipoleExpansion(), child->box().center() - _box.center()));
      }
   }
}

void QuadratureOctreeNode::calcMultipoleExpansionsWithRealTranslation(int n)
{
   if(!isUsefullLeaf())
   {
      _multipoleExpansion = HarmonicSeries<Vector3>(n);

      for(auto child : _children)
      {
         child->calcMultipoleExpansionsWithRealTranslation(n);
      }

      for(auto child : _children)
      {
         if(!child->_quadratures.empty() && !child->isSubdivided() ||
            child->_quadratures.empty() && child->isSubdivided())
            _multipoleExpansion.add(MultipoleTranslator::translateMultipoleWithReal(
               child->multipoleExpansion(), child->box().center() - _box.center()));
      }
   }
}

void QuadratureOctreeNode::initAllMultipoleExpansions(size_t n)
{
   if(isSubdivided() || _quadratures.empty())
   {
      _multipoleExpansion = HarmonicSeries<Vector3>(n);

      for(auto child : _children)
      {
         child->initAllMultipoleExpansions(n);
      }
   }
}

Vector3 QuadratureOctreeNode::calcA(const Vector3& point) const
{
   int n = _multipoleExpansion.order();

   Vector3 res;

   auto distanceSquared = Vector3::distanceSquared(point, box().center());
   auto radius = box().radius();

   if(4 * radius * radius < distanceSquared)
   {
      auto irregularHarmonic = Harmonics::calcIrregularSolidHarmonics(n, point - _box.center());
      res += mult(_multipoleExpansion, irregularHarmonic);
   }
   else
   {
      for(auto child : _children)
      {
         res += child->calcA(point);
      }
   }

   return res;
}

Vector3 QuadratureOctreeNode::calcRot(const Vector3& point) const
{
   Vector3 result;

   int order = _multipoleExpansion.order();
   real eps = 1e-3;
   
   auto distanceSquared = Vector3::distanceSquared(point, box().center());
   auto radius = box().radius();

   if(4 * radius * radius < distanceSquared)
   {
      auto hx1 = Harmonics::calcIrregularSolidHarmonics(
         order, point - _box.center() + Vector3::xAxis() * eps);
      auto hx2 = Harmonics::calcIrregularSolidHarmonics(
         order, point - _box.center() - Vector3::xAxis() * eps);

      auto hy1 = Harmonics::calcIrregularSolidHarmonics(
         order, point - _box.center() + Vector3::yAxis() * eps);
      auto hy2 = Harmonics::calcIrregularSolidHarmonics(
         order, point - _box.center() - Vector3::yAxis() * eps);

      auto hz1 = Harmonics::calcIrregularSolidHarmonics(
         order, point - _box.center() + Vector3::zAxis() * eps);
      auto hz2 = Harmonics::calcIrregularSolidHarmonics(
         order, point - _box.center() - Vector3::zAxis() * eps);

      hx1.subtract(hx2);
      hy1.subtract(hy2);
      hz1.subtract(hz2);

      Vector3 tempRes;

      for(int l = 0; l <= order; l++)
      {
         for(int m = -l; m <= l; m++)
         {
            tempRes.x += 
               _multipoleExpansion.getHarmonic(l, m).z * hy1.getHarmonic(l, m) -
               _multipoleExpansion.getHarmonic(l, m).y * hz1.getHarmonic(l, m);

            tempRes.y += 
               _multipoleExpansion.getHarmonic(l, m).x * hz1.getHarmonic(l, m) -
               _multipoleExpansion.getHarmonic(l, m).z * hx1.getHarmonic(l, m);

            tempRes.z += 
               _multipoleExpansion.getHarmonic(l, m).y * hx1.getHarmonic(l, m) -
               _multipoleExpansion.getHarmonic(l, m).x * hy1.getHarmonic(l, m);
         }
      }

      result += tempRes / (2 * eps);
   }
   else
   {
      for(auto child : _children)
      {
         result += child->calcRot(point);
      }
   }

   return result;
}

size_t QuadratureOctreeNode::getAllNodeCount() const
{
   size_t count = 1;

   for(auto child : _children)
   {
      count += child->getAllNodeCount();
   }
   
   return count;
}

const Box& QuadratureOctreeNode::box() const
{
   return this->_box;
}

bool QuadratureOctreeNode::isSubdivided() const
{
   return !_children.empty();
}

bool QuadratureOctreeNode::isUsefullLeaf() const
{
   return !_quadratures.empty();
}

QuadratureOctreeNode* QuadratureOctreeNode::parent()
{
   return _parent;
}

QuadratureOctreeNode* QuadratureOctreeNode::parent() const
{
   return _parent;
}

std::vector<QuadratureOctreeNode*>& QuadratureOctreeNode::children()
{
   return _children;
}

const std::vector<QuadratureOctreeNode*>& QuadratureOctreeNode::children() const
{
   return _children;
}

const std::vector<Quadrature*>& QuadratureOctreeNode::quadratures() const
{
   return _quadratures;
}

HarmonicSeries<Vector3>& QuadratureOctreeNode::multipoleExpansion()
{
   return _multipoleExpansion;
}

const HarmonicSeries<Vector3>& QuadratureOctreeNode::multipoleExpansion() const
{
   return _multipoleExpansion;
}

QuadratureOctreeNode::~QuadratureOctreeNode()
{
   for(auto child : _children)
   {
      delete child;
   }
}#pragma once
#include <vector>
#include <set>

#include "vector3.cuh"
#include "box.hpp"
#include "quadrature.hpp"
#include "harmonic_series.hpp"
#include "calculation_point_octree.hpp"

class QuadratureOctreeNode
{
private:
   size_t _capacity = 0;
   Box _box;
   std::vector<Quadrature*> _quadratures;
   std::vector<QuadratureOctreeNode*> _children;
   HarmonicSeries<Vector3> _multipoleExpansion;
   QuadratureOctreeNode* _parent;

public:

   QuadratureOctreeNode();
   QuadratureOctreeNode(
      const Box& box,
      const size_t capacity,
      QuadratureOctreeNode* parent = nullptr);

   void insert(Quadrature* point);
   void insert(std::vector<Quadrature*>& points);
   void subdivide();

   const Box& box() const;
   bool isSubdivided() const;
   bool isUsefullLeaf() const;
   QuadratureOctreeNode* parent();
   QuadratureOctreeNode* parent() const;
   std::vector<QuadratureOctreeNode*>& children();
   const std::vector<QuadratureOctreeNode*>& children() const;
   const std::vector<Quadrature*>& quadratures() const;
   HarmonicSeries<Vector3>& multipoleExpansion();
   const HarmonicSeries<Vector3>& multipoleExpansion() const;

   std::vector<Quadrature*> getAllQuadratures() const;
   
   void calcMultipoleExpansionsWithComplexTranslation(int n);
   void calcMultipoleExpansionsWithRealTranslation(int n);
   void initAllMultipoleExpansions(size_t n);

   Vector3 calcA(const Vector3& point) const;
   Vector3 calcRot(const Vector3& point) const;
   size_t getAllNodeCount() const;

   ~QuadratureOctreeNode();

private:
};#pragma once

#define REAL_IS_FLOAT
//#define REAL_IS_DOUBLE

#ifdef REAL_IS_FLOAT

   typedef float real;

#endif // REAL_IS_FLOAT

#ifdef REAL_IS_DOUBLE

   typedef double real;

#endif // REAL_IS_DOUBLE#include "reference_cylinder_data.hpp"

ReferenceCylinderData::ReferenceCylinderData(
   size_t id,
   const Vector3& point,
   const Vector3& B,
   real lengthOfB) :
   id(id), point(point), B(B), lengthOfB(lengthOfB)
{
}#pragma once
#include "vector3.cuh"

struct ReferenceCylinderData
{
   size_t id;
   Vector3 point;
   Vector3 B;
   real lengthOfB;

   ReferenceCylinderData(
      size_t id,
      const Vector3& point,
      const Vector3& B,
      real lengthOfB);
};
#include <iostream>
#include <fstream>

#include "testing_helpers.hpp"
#include "math.hpp"
#include "exeptions.hpp"
#include "integration.hpp"

namespace test
{
   Torus createTorus()
   {
      constexpr real torusRadius = 2;
      constexpr real torusSectionWidth = 0.2;
      
      //return { torusRadius, torusSectionWidth, 80, 8, 8 };
      //return { torusRadius, torusSectionWidth, 40, 8, 8 };
      return { torusRadius, torusSectionWidth, 20, 4, 4 };
   }

   Cylinder createCylinder()
   {
      real cylinderRadius = 1.0;
      real cylinderBottom = -1.5;
      real cylinderTop = 1.5;

      real subdivisionLevel = 1;

      size_t widthSegmentCount = 128 * subdivisionLevel;
      size_t heightSegmentCount = 99 * subdivisionLevel;
      size_t depthSegmentCount = 50 * subdivisionLevel;

      return {
         cylinderBottom,
         cylinderTop,
         cylinderRadius,
         widthSegmentCount,
         heightSegmentCount,
         depthSegmentCount };
   }
   
   std::vector<ReferenceCylinderData> readCylinderData(const std::string& filename)
   {
      std::vector<ReferenceCylinderData> result;

      std::ifstream fin(filename);
      std::string _;
      std::getline(fin, _);
      std::getline(fin, _);
      size_t pointId;

      while(fin >> pointId)
      {
         real px, py, pz;
         real bx, by, bz, bl;

         fin >> px >> py >> pz >> bx >> by >> bz >> bl;

         result.emplace_back(pointId, Vector3(px, py, pz), Vector3(bx, by, bz), bl);
      }

      return result;
   }

   std::vector<BEMQuadrature> quadraturesFromCylinder()
   {
      Cylinder cylinder = createCylinder();
      BasisQuadratures bq = readTriangleBasisQuadratures();

      auto externalCylinderSides = readCylinderData("cylinder/.0");
      auto externalCylinderTop = readCylinderData("cylinder/.0");
      auto externalCylinderBottom = readCylinderData("cylinder/.0");

      auto BEMQuadraturesSide = math::calcBEMquadraturesFromTriangles(
         cylinder.sideTriangles(), bq, externalCylinderSides, 0);

      auto BEMQuadraturesTop = math::calcBEMquadraturesFromTriangles(
         cylinder.topTriangles(), bq, externalCylinderTop, 1);

      auto BEMQuadraturesBottom = math::calcBEMquadraturesFromTriangles(
         cylinder.bottomTriangles(), bq, externalCylinderBottom, -1);

      std::vector<BEMQuadrature> quadratures;
      quadratures.reserve(
         BEMQuadraturesSide.size() +
         BEMQuadraturesTop.size() +
         BEMQuadraturesTop.size());

      quadratures.insert(quadratures.end(), BEMQuadraturesSide.begin(), BEMQuadraturesSide.end());
      quadratures.insert(quadratures.end(), BEMQuadraturesTop.begin(), BEMQuadraturesTop.end());
      quadratures.insert(quadratures.end(), BEMQuadraturesBottom.begin(), BEMQuadraturesBottom.end());

      return quadratures;
   }

   double getTime(void (*f)())
   {
      auto start = std::chrono::steady_clock::now();
      f();
      auto stop = std::chrono::steady_clock::now();
      return getTime(start, stop);
   }

   double getTime(const std::chrono::steady_clock::time_point& start,
                  const std::chrono::steady_clock::time_point& stop)
   {
      return std::chrono::duration_cast<std::chrono::microseconds>
         (stop - start).count() * 1e-6;
   }

   BasisQuadratures readTetrahedronBasisQuadratures()
   {
      BasisQuadratures bq;
      std::string bqDir = "E:///bachelors/FMM/FMMGPU/basis_quadratures/";

      try
      {
         bq.initFromTXT(bqDir + "keast 7 x.txt", bqDir + "keast 7 w.txt");
         //std::cout << "Quadratures were successfully read. Order = " << bq._order() << std::endl;
      }
      catch(Exeption ex)
      {
         std::cout << ex;
      }

      return bq;
   }

   BasisQuadratures readTriangleBasisQuadratures()
   {
      BasisQuadratures bq;
      std::string path = "basis_quadratures/";

      try
      {
         bq.initFromTXT(path + "gauss7_xy.txt", path + "gauss7_w.txt");
      }
      catch(Exeption ex)
      {
         std::cout << ex.message;
      }

      return bq;
   }

   std::vector<Vector3> createPoints(const Vector3& begin, const Vector3& end, int n)
   {
      if(n == 1)
      {
         return { (end + begin) / 2 };
      }
      else
      {
         Vector3 step = (end - begin) / (n - 1);
         std::vector<Vector3> res(n);

         for(size_t i = 0; i < n; i++)
         {
            res[i] = begin + step * i;
         }

         return res;
      }
   }



   std::vector<Vector3> createRandomPoints(const Box& box, int n)
   {
      std::vector<Vector3> res(n);
      std::srand(std::time(0));

      for (int i = 0; i < n; ++i)
      {
         real x = math::randBetween(
            box.center().x - box.halfDimensions().x,
            box.center().x + box.halfDimensions().x);

         real y = math::randBetween(
            box.center().y - box.halfDimensions().y,
            box.center().y + box.halfDimensions().y);

         real z = math::randBetween(
            box.center().z - box.halfDimensions().z,
            box.center().z + box.halfDimensions().z);

         res[i] = { x, y, z };
      }

      return res;
   }
   

   void printSeparateLine(std::ostream& os, size_t count)
   {
      for (int i = 0; i < count; ++i)
      {
         os << "-";
      }

      os << std::endl;
   }
}
#pragma once
#include <chrono>

#include "torus.hpp"
#include "basis_quadratures.hpp"
#include "bem_quadrature.hpp"
#include "box.hpp"
#include "cylinder.hpp"
#include "reference_cylinder_data.hpp"

namespace test
{
   Torus createTorus();
   Cylinder createCylinder();
   std::vector<BEMQuadrature> quadraturesFromCylinder();
   std::vector<ReferenceCylinderData> readCylinderData(
      const std::string& filename);

   double getTime(void (*f)());
   double getTime(const std::chrono::steady_clock::time_point& start,
                  const std::chrono::steady_clock::time_point& stop);
   BasisQuadratures readTetrahedronBasisQuadratures();
   BasisQuadratures readTriangleBasisQuadratures();
   std::vector<Vector3> createPoints(const Vector3& begin, const Vector3& end, int n);
   std::vector<Vector3> createRandomPoints(const Box& box, int n);
   void printSeparateLine(std::ostream& os, size_t count);
}
#include "tetrahedron.hpp"

Tetrahedron::Tetrahedron()
{
   points.resize(4);
}

Tetrahedron::Tetrahedron(Vector3& a, Vector3& b, Vector3& c, Vector3& d)
   :points({a, b, c, d})
{
}

real Tetrahedron::volume() const
{
   return abs(Vector3::dot(a() - d(), Vector3::cross(b() - d(), c() - d()))) / 6.0;
}

Vector3& Tetrahedron::a()
{
   return points[0];
}

Vector3 Tetrahedron::a() const
{
   return points[0];
}

Vector3& Tetrahedron::b()
{
   return points[1];
}

Vector3 Tetrahedron::b() const
{
   return points[1];
}

Vector3& Tetrahedron::c()
{
   return points[2];
}

Vector3 Tetrahedron::c() const
{
   return points[2];
}

Vector3& Tetrahedron::d()
{
   return points[3];
}

Vector3 Tetrahedron::d() const
{
   return points[3];
}
#pragma once
#include <vector>

#include "vector3.cuh"

class Tetrahedron
{
public:
   Tetrahedron();
   Tetrahedron(Vector3& a, Vector3& b, Vector3& c, Vector3& d);
   std::vector<Vector3> points;
   real volume() const;

   Vector3& a();
   Vector3& b();
   Vector3& c();
   Vector3& d();

   Vector3 a() const;
   Vector3 b() const;
   Vector3 c() const;
   Vector3 d() const;
};#include <cmath>
#include "torus.hpp"
#include "hexahedron.hpp"
#include <fstream>

void saveHexahedraAsOBJ(std::vector<Hexahedron>& hexahedra, std::string filename);
void saveTetrahedraAsOBJ(std::vector<Tetrahedron>& tetrahedra, std::string filename);

Torus::Torus(const real radius,
             const real sectionWidth,
             const int onLengthStepCount,
             const int onWidthStepCount,
             const int onHeightStepCount)
   : _radius(radius), _sectionWidth(sectionWidth),
   _onLengthStepCount(onLengthStepCount),
   _onWidthStepCount(onWidthStepCount),
   _onHeightStepCount(onHeightStepCount)
{
   std::vector<Hexahedron> hexahedra(onLengthStepCount * onWidthStepCount * onHeightStepCount);
   buildHexahedra(hexahedra);
   buildTetrahedra(hexahedra);

   saveHexahedraAsOBJ(hexahedra, "testmesh/debsHex.obj");
   saveTetrahedraAsOBJ(tetrahedra, "testmesh/debsTet.obj");
}

real Torus::innerRadius() const
{
   return _radius - _sectionWidth / 2.0;
}

real Torus::outerRadius() const
{
   return _radius + _sectionWidth / 2.0;
}

real Torus::bottom() const
{
   return -1.0 * _sectionWidth / 2.0;
}

real Torus::top() const
{
   return _sectionWidth / 2.0;
}

real Torus::stepAngle() const
{
   return 360.0 / _onLengthStepCount * 3.14159265359 / 180.0;
}

void Torus::buildHexahedra(std::vector<Hexahedron>& hexahedra)
{
   const real hexahedronHeight = _sectionWidth / _onHeightStepCount;

   auto getInnerRadiusPoint = [&](int n)
   {
      return Vector3(innerRadius() * cos(stepAngle() * n), innerRadius() * sin(stepAngle() * n), 0);
   };

   auto getPointOnWidthSection = [&](Vector3 innerRadiusPoint, int n)
   {
      real onWidthStepLength = _sectionWidth / _onWidthStepCount;
      return innerRadiusPoint + innerRadiusPoint.normalized() * onWidthStepLength * n;
   };

   size_t hexahedronsCount = 0;

   for(size_t lengthCounter = 0; lengthCounter < _onLengthStepCount; lengthCounter++)
   {
      Vector3 innerRadiusPoint = getInnerRadiusPoint(lengthCounter);
      Vector3 nextInnerRadiusPoint = getInnerRadiusPoint(lengthCounter + 1);

      for(size_t widthCounter = 0; widthCounter < _onWidthStepCount; widthCounter++)
      {
         Vector3 rightOnWidthSectionPoint = getPointOnWidthSection(innerRadiusPoint, widthCounter);
         Vector3 nextRightOnWidthSectionPoint = getPointOnWidthSection(innerRadiusPoint, widthCounter + 1);

         Vector3 leftOnWidthSectionPoint = getPointOnWidthSection(nextInnerRadiusPoint, widthCounter);
         Vector3 nextLeftOnWidthSectionPoint = getPointOnWidthSection(nextInnerRadiusPoint, widthCounter + 1);

         for(size_t heightCounter = 0; heightCounter < _onHeightStepCount; heightCounter++)
         {
            real hexahedronBottom = bottom() + hexahedronHeight * heightCounter;
            real hexahedronTop = bottom() + hexahedronHeight * (heightCounter + 1);

            std::vector<Vector3> points(8);

            points[0] = Vector3(rightOnWidthSectionPoint.x, rightOnWidthSectionPoint.y, hexahedronBottom);
            points[1] = Vector3(nextRightOnWidthSectionPoint.x, nextRightOnWidthSectionPoint.y, hexahedronBottom);
            points[2] = Vector3(leftOnWidthSectionPoint.x, leftOnWidthSectionPoint.y, hexahedronBottom);
            points[3] = Vector3(nextLeftOnWidthSectionPoint.x, nextLeftOnWidthSectionPoint.y, hexahedronBottom);

            points[4] = Vector3(rightOnWidthSectionPoint.x, rightOnWidthSectionPoint.y, hexahedronTop);
            points[5] = Vector3(nextRightOnWidthSectionPoint.x, nextRightOnWidthSectionPoint.y, hexahedronTop);
            points[6] = Vector3(leftOnWidthSectionPoint.x, leftOnWidthSectionPoint.y, hexahedronTop);
            points[7] = Vector3(nextLeftOnWidthSectionPoint.x, nextLeftOnWidthSectionPoint.y, hexahedronTop);

            hexahedra[hexahedronsCount++] = Hexahedron(points);
         }
      }
   }
}

void Torus::buildTetrahedra(std::vector<Hexahedron>& hexahedra)
{
   tetrahedra.reserve(hexahedra.size() * 5);

   for(auto& hex : hexahedra)
   {
      tetrahedra.emplace_back(Tetrahedron(hex.points[0], hex.points[1], hex.points[3], hex.points[5]));
      tetrahedra.emplace_back(Tetrahedron(hex.points[0], hex.points[3], hex.points[5], hex.points[6]));
      tetrahedra.emplace_back(Tetrahedron(hex.points[0], hex.points[2], hex.points[3], hex.points[6]));
      tetrahedra.emplace_back(Tetrahedron(hex.points[0], hex.points[4], hex.points[5], hex.points[6]));
      tetrahedra.emplace_back(Tetrahedron(hex.points[3], hex.points[5], hex.points[6], hex.points[7]));
   }
}

void saveHexahedraAsOBJ(std::vector<Hexahedron>& hexahedra, std::string filename)
{
   std::ofstream fout(filename);

   for(size_t i = 0; i < hexahedra.size(); i++)
   {
      for(auto& p : hexahedra[i].points)
      {
         fout << "v" << " " << p.x << " " << p.y << " " << p.z << std::endl;
      }
   }

   for(size_t i = 0; i < hexahedra.size(); i++)
   {
      int c = i * 8 + 1;

      fout << "f" << " " << c + 0 << " " << c + 1 << " " << c + 4 << std::endl; // right
      fout << "f" << " " << c + 1 << " " << c + 4 << " " << c + 5 << std::endl; // right

      fout << "f" << " " << c + 0 << " " << c + 2 << " " << c + 6 << std::endl; // inner
      fout << "f" << " " << c + 0 << " " << c + 4 << " " << c + 6 << std::endl; // inner

      fout << "f" << " " << c + 0 << " " << c + 1 << " " << c + 3 << std::endl; // bot
      fout << "f" << " " << c + 0 << " " << c + 2 << " " << c + 3 << std::endl; // bot

      fout << "f" << " " << c + 4 << " " << c + 5 << " " << c + 7 << std::endl; // top
      fout << "f" << " " << c + 4 << " " << c + 6 << " " << c + 7 << std::endl; // top

      fout << "f" << " " << c + 1 << " " << c + 3 << " " << c + 7 << std::endl; // outer
      fout << "f" << " " << c + 1 << " " << c + 5 << " " << c + 7 << std::endl; // outer

      fout << "f" << " " << c + 2 << " " << c + 6 << " " << c + 7 << std::endl; // left
      fout << "f" << " " << c + 2 << " " << c + 3 << " " << c + 7 << std::endl; // left
   }

   fout.close();
}

void saveTetrahedraAsOBJ(std::vector<Tetrahedron>& tetrahedra, std::string filename)
{
   std::ofstream fout(filename);

   for(size_t i = 0; i < tetrahedra.size(); i++)
   {
      for(auto& t : tetrahedra[i].points)
      {
         fout << "v" << " " << t.x << " " << t.y << " " << t.z << std::endl;
      }
   }

   for(size_t i = 0; i < tetrahedra.size(); i++)
   {
      int c = i * 4 + 1;

      fout << "f" << " " << c + 0 << " " << c + 1 << " " << c + 3 << std::endl;
      fout << "f" << " " << c + 0 << " " << c + 1 << " " << c + 2 << std::endl;
      fout << "f" << " " << c + 0 << " " << c + 2 << " " << c + 3 << std::endl;
      fout << "f" << " " << c + 1 << " " << c + 2 << " " << c + 3 << std::endl;
   }

   fout.close();
}


#pragma once
#include <vector>
#include "vector3.cuh"
#include "tetrahedron.hpp"
#include "hexahedron.hpp"
#include "real.hpp"

class Torus
{
private:
   const real _radius;
   const real _sectionWidth;
   const int _onLengthStepCount;
   const int _onWidthStepCount;
   const int _onHeightStepCount;
public:
   Torus(const real radius,
         const real sectionWidth,
         const int onLengthStepCount,
         const int onWidthStepCount,
         const int onHeightStepCount);
   real innerRadius() const;
   real outerRadius() const;
   real bottom() const;
   real top() const;
   real stepAngle() const;
   std::vector<Tetrahedron> tetrahedra;

private:
   void buildHexahedra(std::vector<Hexahedron>& hexahedra);
   void buildTetrahedra(std::vector<Hexahedron>& hexahedra);
};

#pragma once
#include <vector>
#include "real.hpp"
#include "math.hpp"
#include "harmonics.hpp"
#include "cuComplex.h"

namespace kernels
{
   std::vector<real> addVectors(const std::vector<real>& a,
                                const std::vector<real>& b);

   void translateAllCPU(
      Vector3* result,
      const real* a,
      const Vector3* b,
      size_t harmonicCount,
      size_t harmonicOrder);

   void translateAllGPU(
      Vector3* result,
      const real* a,
      const Vector3* b,
      size_t harmonicCount,
      size_t harmonicOrder);

   void translateAllCPUMatrix(
      std::vector<Complex>& result,
      const std::vector<Complex>& a,
      const std::vector<Complex>& b,
      size_t harmonicCount,
      size_t harmonicOrder);

   void translateAllGPUMatrix(
      Complex* result,
      const Complex* a,
      const Complex* b,
      size_t harmonicCount,
      size_t harmonicOrder);

   void translateAllCPUMatrixBLAS(
      real* result,
      const real* a,
      const real* b,
      size_t harmonicCount,
      size_t harmonicOrder);

   void translateAllGPUMatrixCuBLAS(
      real* result,
      const real* a,
      const real* b,
      size_t harmonicCount,
      size_t harmonicOrder);
   
   void translateAllGPUMatrixCuBLAS(
      RealMatrix& result,
      const RealMatrix& a,
      const real* b,
      size_t harmonicCount,
      size_t harmonicOrder);
}
#include "translation_algorithms.hpp"
#include "kernels.cuh"
#include "cblas.h"
#include "multipole_translator.hpp"
#include "blass_callers.hpp"

#include <omp.h>

void kernels::translateAllCPU(
   Vector3* result,
   const real* a,
   const Vector3* b,
   size_t harmonicCount, size_t harmonicOrder)
{
   size_t harmonicLength = (harmonicOrder + 1) * (harmonicOrder + 1);

#pragma omp parallel for
   for(int harmonicId = 0; harmonicId < harmonicCount; harmonicId++)
   {
      size_t harmonicBegin = harmonicLength * harmonicId;
      size_t harmonicEnd = harmonicBegin + harmonicLength;

      for(int l = 0; l <= harmonicOrder; l++)
      {
         Vector3 zeroRes = 0;

         for(int lambda = 0; lambda <= l; lambda++)
         {
            int dl = l - lambda;

            for(int mu = -lambda; mu <= lambda; mu++)
            {
               if(-dl <= mu && mu <= +dl)
               {
                  zeroRes += getHarmonic(b, harmonicBegin, lambda, mu) *
                     getHarmonic(a, harmonicBegin, dl, mu) *
                     MultipoleTranslator::multipoleTranslationFactor(0, mu);
               }
            }
         }

         result[lmToIndex(harmonicBegin, l, 0)] = zeroRes;

         for(int m = 1; m <= l; m++)
         {
            Vector3 realRes = 0;
            Vector3 imagRes = 0;

            for(int lambda = 0; lambda <= l; lambda++)
            {
               int dl = l - lambda;

               for(int mu = -lambda; mu <= lambda; mu++)
               {
                  int dm = m - mu;
                  int dnm = -m - mu;

                  Vector3 RR = getReal(b, harmonicBegin, lambda, mu);
                  Vector3 IR = getImag(b, harmonicBegin, lambda, mu);

                  real RM = 0;
                  real IM = 0;

                  real RnM = 0;
                  real InM = 0;

                  if(-dl <= dm && dm <= dl)
                  {
                     RM = getReal(a, harmonicBegin, dl, dm);
                     IM = getImag(a, harmonicBegin, dl, dm);

                     realRes += (RR * RM - IR * IM) * 
                        MultipoleTranslator::multipoleTranslationFactor(m, mu);
                     imagRes += (RR * IM + IR * RM) * 
                        MultipoleTranslator::multipoleTranslationFactor(m, mu);
                  }

                  if(-dl <= dnm && dnm <= dl)
                  {
                     RnM = getReal(a, harmonicBegin, dl, dnm);
                     InM = getImag(a, harmonicBegin, dl, dnm);

                     realRes += (RR * RnM - IR * InM) * 
                        MultipoleTranslator::multipoleTranslationFactor(-m, mu);
                     imagRes -= (RR * InM + IR * RnM) * 
                        MultipoleTranslator::multipoleTranslationFactor(-m, mu);
                  }
               }
            }

            result[lmToIndex(harmonicBegin, l, m)] = realRes * math::R_SQRT_2;
            result[lmToIndex(harmonicBegin, l, -m)] = imagRes * math::R_SQRT_2;
         }
      }
   }
}

void kernels::translateAllCPUMatrix(
   std::vector<Complex>& result,
   const std::vector<Complex>& a,
   const std::vector<Complex>& b,
   size_t harmonicCount,
   size_t harmonicOrder)
{
   result = math::multMatricesAsVectors(
      a,
      b,
      (harmonicOrder + 1) * (harmonicOrder + 1),
      harmonicCount,
      (harmonicOrder + 1) * (harmonicOrder + 1));
}


void kernels::translateAllCPUMatrixBLAS(
   real* result,
   const real* a,
   const real* b,
   size_t harmonicCount,
   size_t harmonicOrder)
{
   size_t harmonicLength = (harmonicOrder + 1) * (harmonicOrder + 1);

   int m = harmonicLength;
   int k = harmonicLength;
   int n = harmonicCount;
   int lda = m, ldb = k, ldc = m;
   const real alpha = 1;
   const real beta = 0;

   blas::multMatrices(CBLAS_ORDER::CblasColMajor,
               CBLAS_TRANSPOSE::CblasNoTrans,
               CBLAS_TRANSPOSE::CblasNoTrans,
               m, n, k,
               alpha,
               b, ldb, a, lda,
               beta,
               result, ldc);
}#pragma once
#include "translation_algorithms.hpp"
#include <vector>
#include "kernels.cuh"
#include "cuda_helper.hpp"
#include "dev_ptr.hpp"
#pragma comment (lib, "cublas.lib")
#include "blass_callers.hpp"
#include "cublasLt.h"

namespace kernels
{
   std::vector<real> addVectors(const std::vector<real>& a,
                                const std::vector<real>& b)
   {
      size_t size = a.size();

      cuda::DevPtr<real> dev_a(a.data(), a.size());
      cuda::DevPtr<real> dev_b(b.data(), b.size());
      cuda::DevPtr<real> dev_res(size);

      addingKernel<<<1, size>>>(dev_res.data(), dev_a.data(), dev_b.data());

      cuda::tryKernelLaunch();
      cuda::tryKernelSynchronize();

      real* res = new real[size];
      dev_res.copyToHost(res);

      return std::vector<real>(res, res + size);
   }

   void translateAllGPU(Vector3* result,
                        const real* a,
                        const Vector3* b,
                        size_t harmonicCount, size_t harmonicOrder)
   {
      size_t harmonicLength = (harmonicOrder + 1) * (harmonicOrder + 1);

      cuda::DevPtr<Vector3> result_dev(harmonicCount * harmonicLength);
      cuda::DevPtr<real> a_dev(a, harmonicCount * harmonicLength, 0);
      cuda::DevPtr<Vector3> b_dev(b, harmonicCount * harmonicLength, 0);

      dim3 BLOCKS((harmonicCount + THREADS_PER_BLOCK - 1) / THREADS_PER_BLOCK);
      dim3 THREADS(THREADS_PER_BLOCK, harmonicOrder);

      kernels::translateAllGPUKernelSimpleXY<<<BLOCKS, THREADS>>>
         (result_dev.data(), a_dev.data(), b_dev.data(), harmonicCount, harmonicOrder);
      
      cuda::tryKernelLaunch();
      cuda::tryKernelSynchronize();

      result_dev.copyToHost(result);
   }

   void kernels::translateAllGPUMatrix(
      Complex* result,
      const Complex* a,
      const Complex* b,
      size_t harmonicCount,
      size_t harmonicOrder)
   {
      size_t harmonicLength = (harmonicOrder + 1) * (harmonicOrder + 1);

      size_t harLenPadded = math::nextDevisible(
         harmonicLength,
         THREADS_PER_BLOCK);

      size_t harCountPadded = math::nextDevisible(
         harmonicCount,
         THREADS_PER_BLOCK);

      cuda::DevPtr<Complex> aDev(a, harCountPadded * harLenPadded);
      ComplexKernelMatrix A;

      A.width = A.stride = harLenPadded;
      A.height = harCountPadded;
      A.elements = aDev.data();

      cuda::DevPtr<Complex> bDev(b, harLenPadded * harLenPadded);
      ComplexKernelMatrix B;

      B.width = B.stride = harLenPadded;
      B.height = harLenPadded;
      B.elements = bDev.data();

      cuda::DevPtr<Complex> cDev(harCountPadded * harLenPadded);
      ComplexKernelMatrix C;

      C.width = C.stride = harLenPadded;
      C.height = harCountPadded;
      C.elements = cDev.data();

      dim3 dimBlock(THREADS_PER_BLOCK, THREADS_PER_BLOCK);
      dim3 dimGrid(B.width / dimBlock.x, A.height / dimBlock.y);
      matMulKernel<<<dimGrid, dimBlock >>>(A, B, C);

      cuda::tryKernelLaunch();
      cuda::tryKernelSynchronize();

      cDev.copyToHost(result);
   }

   void translateAllGPUMatrixCuBLAS(
      real* result,
      const real* a,
      const real* b,
      size_t harmonicCount,
      size_t harmonicOrder)
   {
      size_t harmonicLength = (harmonicOrder + 1) * (harmonicOrder + 1);

      cuda::DevPtr<real> aDev(a, harmonicCount * harmonicLength);
      cuda::DevPtr<real> bDev(b, harmonicLength * harmonicLength);
      cuda::DevPtr<real> cDev(harmonicCount * harmonicLength);

      int m = harmonicLength;
      int k = harmonicLength;
      int n = harmonicCount;
      int lda = m, ldb = k, ldc = m;
      const real alpha = 1;
      const real beta = 0;
      
      cublasHandle_t handle;
      cublasCreate(&handle);
      
      blas::multMatricesCUBLAS(
         handle, CUBLAS_OP_N, CUBLAS_OP_N, m, n, k, &alpha,
         bDev.data(), ldb, aDev.data(), lda, &beta, cDev.data(), ldc);
      
      cublasDestroy(handle);

      cDev.copyToHost(result);
   }

   void translateAllGPUMatrixCuBLAS(
      RealMatrix& result,
      const RealMatrix& a,
      const real* b, 
      size_t harmonicCount, 
      size_t harmonicOrder)
   {
      size_t harmonicLength = (harmonicOrder + 1) * (harmonicOrder + 1);

      real* aDevs;
      real* bDevs;
      real* cDevs;

      cudaMalloc(&aDevs, harmonicCount * harmonicLength * sizeof(real) * 3);
      cudaMalloc(&bDevs, harmonicLength * harmonicLength * sizeof(real) * 3);
      cudaMalloc(&cDevs, harmonicCount * harmonicLength * sizeof(real) * 3);

      for(size_t c = 0; c < 3; c++)
      {
         cudaMemcpy(
            aDevs + harmonicCount * harmonicLength * c, a[c].data(),
            harmonicCount * harmonicLength * sizeof(real),
            cudaMemcpyHostToDevice);

         cudaMemcpy(
            bDevs + harmonicLength * harmonicLength * c, b,
            harmonicLength * harmonicLength * sizeof(real),
            cudaMemcpyHostToDevice);
      }
      
      int m = harmonicLength;
      int k = harmonicLength;
      int n = harmonicCount;
      int lda = m, ldb = k, ldc = m;
      const real alpha = 1;
      const real beta = 0;

      cublasHandle_t handle;
      cublasCreate(&handle);

      blas::multMatricesStridedBatchedCUBLAS(
         handle, CUBLAS_OP_N, CUBLAS_OP_N, m, n, k, &alpha,
         bDevs, ldb, harmonicLength * harmonicLength,
         aDevs, lda, harmonicCount * harmonicLength,
         &beta, cDevs, ldc, harmonicCount * harmonicLength, 3);

      cublasDestroy(handle);

      for(size_t c = 0; c < 3; c++)
      {
         cudaMemcpy(
            result[c].data(), cDevs + harmonicCount * harmonicLength * c,
            harmonicCount * harmonicLength * sizeof(real),
            cudaMemcpyDeviceToHost);
      }

      cudaFree(aDevs);
      cudaFree(bDevs);
      cudaFree(cDevs);
   }

   size_t lmToIndex(int harmonicBegin,
                    int l, int m)
   {
      return harmonicBegin + l * l + l + m;
   }

   size_t lmToIndex(int l, int m)
   {
      return l * l + l + m;
   }

   __all__ real strangeFactor(int m, int mu)
   {
      return pow(-1, -0.5 * (abs(m) - abs(mu) - abs(m - mu)));
   }
}#include "triangle.hpp"
#include "math.hpp"

Triangle::Triangle()
{
   points.resize(3);
}

Triangle::Triangle(const Vector3& a, const Vector3& b, const Vector3& c)
   : points({a, b, c})
{
}

real Triangle::area() const
{
   Vector3 ab(b().x - a().x, b().y - a().y, b().z - a().z);
   Vector3 ac(c().x - a().x, c().y - a().y, c().z - a().z);

   real t0 = ab.y * ac.z - ab.z * ac.y;
   real t1 = ab.z * ac.x - ab.x * ac.z;
   real t2 = ab.x * ac.y - ab.y * ac.x;

   return 0.5 * sqrt(t0 * t0 + t1 * t1 + t2 * t2);
}

Vector3 Triangle::center() const
{
   return (a() + b() + c()) / 3;
}

Box Triangle::boundingBox() const
{
   return math::getBoundingBox(points);
}

Vector3& Triangle::a()
{
   return points[0];
}

Vector3 Triangle::a() const
{
   return points[0];
}

Vector3& Triangle::b()
{
   return points[1];
}

Vector3 Triangle::b() const
{
   return points[1];
}

Vector3& Triangle::c()
{
   return points[2];
}

Vector3 Triangle::c() const
{
   return points[2];
}
#pragma once
#include <vector>

#include "box.hpp"
#include "vector3.cuh"

class Triangle
{
public:
   Triangle();
   Triangle(const Vector3& a, const Vector3& b, const Vector3& c);
   std::vector<Vector3> points;
   real area() const;
   Vector3 center() const;
   Box boundingBox() const;

   Vector3& a();
   Vector3& b();
   Vector3& c();

   Vector3 a() const;
   Vector3 b() const;
   Vector3 c() const;
};#pragma once
#include <vector>
//#include <thrust/complex.h>
#include <cuComplex.h>
#include "real.hpp"

template <class T>
using Matrix = std::vector<std::vector<T>>;

//typedef thrust::complex<real> Complex;

#ifdef REAL_IS_FLOAT
typedef cuComplex Complex;
#else
typedef cuDoubleComplex Complex;
#endif

typedef Matrix<Complex> ComplexMatrix;
typedef Matrix<real> RealMatrix;

typedef unsigned int uint;

#define __all__ __device__ __host__#include <exception>
#include <iomanip>
#include "vector3.cuh"

Vector3::Vector3(const Vector3& vector)
{
   x = vector.x;
   y = vector.y;
   z = vector.z;
}

Vector3::Vector3(Vector3&& vector) noexcept
{
   x = std::move(vector.x);
   y = std::move(vector.y);
   z = std::move(vector.z);
}

Vector3::Vector3(real x, real y, real z)
   : x(x), y(y), z(z) {}

real& Vector3::operator[](int i)
{
   switch(i)
   {
      case 0: return x;
      case 1: return y;
      case 2: return z;
   }
}

__all__ const real Vector3::operator[](int i) const
{
   return *((real*)this + i);
}

Vector3& Vector3::operator=(Vector3&& vector) noexcept
{
   x = std::move(vector.x);
   y = std::move(vector.y);
   z = std::move(vector.z);

   return *this;
}

Vector3& Vector3::operator=(const Vector3& vector)
{
   x = vector.x;
   y = vector.y;
   z = vector.z;

   return *this;
}

Vector3 Vector3::operator +(const Vector3& rhs) const
{
   Vector3 res;
   res.x = this->x + rhs.x;
   res.y = this->y + rhs.y;
   res.z = this->z + rhs.z;

   return res;
}

Vector3 Vector3::operator -(const Vector3& rhs) const
{
   Vector3 res;
   res.x = this->x - rhs.x;
   res.y = this->y - rhs.y;
   res.z = this->z - rhs.z;

   return res;
}

Vector3 Vector3::operator *(const real fac) const
{
   Vector3 res;
   res.x = this->x * fac;
   res.y = this->y * fac;
   res.z = this->z * fac;

   return res;
}

Vector3 Vector3::operator /(const real fac) const
{
   Vector3 res;
   res.x = this->x / fac;
   res.y = this->y / fac;
   res.z = this->z / fac;

   return res;
}

Vector3& Vector3::operator +=(const Vector3& rhs)
{
   this->x += rhs.x;
   this->y += rhs.y;
   this->z += rhs.z;

   return *this;
}

Vector3& Vector3::operator -=(const Vector3& rhs)
{
   this->x -= rhs.x;
   this->y -= rhs.y;
   this->z -= rhs.z;

   return *this;
}

Vector3& Vector3::operator *=(const real fac)
{
   this->x *= fac;
   this->y *= fac;
   this->z *= fac;

   return *this;
}

Vector3& Vector3::operator /=(const real fac)
{
   if(fac != 0)
   {
      this->x /= fac;
      this->y /= fac;
      this->z /= fac;
   }
   else
   {
      this->x = 0;
      this->y = 0;
      this->z = 0;
   }

   return *this;
}

real Vector3::lengthSquared() const
{
   return this->x * this->x +
      this->y * this->y +
      this->z * this->z;
}

real Vector3::length() const
{
   return sqrt(this->x * this->x +
               this->y * this->y +
               this->z * this->z);
}

Vector3 Vector3::normalized() const
{
   Vector3 res;
   real l = length();

   if(l)
   {
      res.x = this->x / l;
      res.y = this->y / l;
      res.z = this->z / l;
   }

   return res;
}

void Vector3::normalize()
{
   real l = length();

   if(l != 0)
   {
      this->x /= l;
      this->y /= l;
      this->z /= l;
   }
}

void Vector3::limit(const real limitLength)
{
   real l = length();

   if(l != 0 && l > limitLength)
   {
      this->x = this->x / l * limitLength;
      this->y = this->y / l * limitLength;
      this->z = this->z / l * limitLength;
   }
}

void Vector3::setLength(const real newLength)
{
   normalize();
   this->x *= newLength;
   this->y *= newLength;
   this->z *= newLength;
}

Vector3 Vector3::perp() const
{
   return Vector3(-y, x);
}

Vector3 Vector3::direction(const Vector3& from, const Vector3& to)
{
   Vector3 res = to - from;
   return res.normalized();
}

real Vector3::distanceSquared(const Vector3& vec1, const Vector3& vec2)
{
   return (vec1 - vec2).lengthSquared();
}

real Vector3::dot(const Vector3& vec1, const Vector3& vec2)
{
   return vec1.x * vec2.x + vec1.y * vec2.y + vec1.z * vec2.z;
}

Vector3 Vector3::cross(const Vector3& vec1, const Vector3& vec2)
{
   return Vector3(vec1.y * vec2.z - vec1.z * vec2.y,
                  vec1.z * vec2.x - vec1.x * vec2.z,
                  vec1.x * vec2.y - vec1.y * vec2.x);
}

Vector3 Vector3::xAxis()
{
    return Vector3(1);
}

Vector3 Vector3::yAxis()
{
   return Vector3(0, 1);
}

Vector3 Vector3::zAxis()
{
   return Vector3(0, 0, 1);
}

void Vector3::printWithWidth(std::ostream& os, size_t width)
{
   os << std::fixed;
   os << "( ";
   os << std::setw(width) << x << ", ";
   os << std::setw(width) << y << ", ";
   os << std::setw(width) << z << " )";
}

Vector3 Vector3::leadingCos()
{
   real l = length();

   return Vector3(x / l, y / l, z / l);
}

real Vector3::r() const
{
   return sqrt(x * x + y * y + z * z);
}

real Vector3::t() const
{
   return atan(sqrt(x * x + y + y) / z);
}

real Vector3::f() const
{
   return atan2(y, x);
}

std::ostream& operator<<(std::ostream& os, const Vector3& vec)
{
   os << "(" << vec.x << ", " << vec.y << ", " << vec.z << ")";
   return os;
}
#pragma once
#include <ostream>
#include "cuda_runtime.h"
#include "device_launch_parameters.h"
#include "real.hpp"
#include "typedefs.hpp"

class Vector3
{
public:
   real x;
   real y;
   real z;

   __all__ Vector3(const Vector3& vector);
   __all__ Vector3(Vector3&& vector) noexcept;
   __all__ Vector3(real x = 0, real y = 0, real z = 0);

   __all__ real& operator[](int i);
   __all__ const real operator[](int i) const;

   __all__ Vector3& operator=(Vector3&& vector) noexcept;
   __all__ Vector3& operator=(const Vector3& vector);

   __all__ Vector3 operator +(const Vector3& rhs) const;
   __all__ Vector3 operator -(const Vector3& rhs) const;
   __all__ Vector3 operator *(const real fac) const;
   __all__ Vector3 operator /(const real fac) const;

   __all__ Vector3& operator +=(const Vector3& rhs);
   __all__ Vector3& operator -=(const Vector3& rhs);
   __all__ Vector3& operator *=(const real fac);
   __all__ Vector3& operator /=(const real fac);

   __all__ real lengthSquared() const;
   __all__ real length() const;
   __all__ Vector3 normalized() const;
   __all__ Vector3 perp() const;

   __all__ void normalize();
   __all__ void limit(const real limitLength);
   __all__ void setLength(const real newLength);
   __all__ Vector3 leadingCos();

   __all__ real r() const;
   __all__ real t() const;
   __all__ real f() const;

   __all__ static Vector3 direction(const Vector3& from, const Vector3& to);
   __all__ static real distanceSquared(const Vector3& vec1, const Vector3& vec2);
   __all__ static real dot(const Vector3& vec1, const Vector3& vec2);
   __all__ static Vector3 cross(const Vector3& vec1, const Vector3& vec2);

   __all__ static Vector3 xAxis();
   __all__ static Vector3 yAxis();
   __all__ static Vector3 zAxis();

   __all__ void printWithWidth(std::ostream& os, size_t width);
};

std::ostream& operator<<(std::ostream& os, const Vector3& vec);